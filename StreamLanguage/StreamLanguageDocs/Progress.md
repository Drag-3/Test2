## Progress Presentation on the Development of the Streaming Language

### Introduction

#### Project Overview
I am attempting to develop a new programming language based around the concept of streams.
This project is to explore the development of a new programming language, if all goes well, it may even be useful.


### Background

- **Programming Languages**: Programming languages are essential tools for software development, providing a means to communicate instructions to computers.
- Programming languages can be classified into different types, such as high-level, low-level, and domain-specific languages. ![image](https://cdn.educba.com/academy/wp-content/uploads/2020/01/Types-of-Computer-Languages.jpg)
- High level languages such as Python, Java, and C++ are widely used for general-purpose programming, while domain-specific languages are designed for specific applications or tasks.
- Low level languages like Assembly are closer to machine code and are used for system-level programming.
- Domain-specific languages are designed for specific applications or tasks, such as SQL for database management and HTML for web development.
- The development of a new programming language involves designing its syntax, semantics, and core concepts, as well as implementing a compiler or interpreter to process and execute the code.
- The design of a programming language is influenced by various factors, including the target audience, the intended use cases, and the desired features and capabilities.
#### Parts of a Programming Language
- **Lexer**: The lexer is responsible for breaking the input stream into tokens, which are the smallest units of the language.
- Some examples of lexer tokens include identifiers, keywords, literals, and operators.
- The lexer uses regular expressions to define the rules for tokenizing the input code.
```python
def t_IDENTIFIER(t):
    r'[a-zA-Z_][a-zA-Z0-9_]*'  # Match a sequence of letters, digits, and underscores not starting with a digit
    t.type = reserved.get(t.value, 'IDENTIFIER')
    return t
```
- **Parser**: The parser processes the tokens generated by the lexer and builds a parse tree, which represents the syntactic structure of the code.
- The parse tree is used to validate the code and is an interpretation of its meaning, which is used for code generation or interpretation.
- A parser will typically use a grammar to define the syntax of the language and generate the parse tree based on the input code.
```python
def p_conditional(p):
    '''conditional : IF LPAREN expression RPAREN block_statement ELSE block_statement
                    | IF LPAREN expression RPAREN block_statement'''
    if len(p) == 7:  # if-else
        p[0] = ('if-else', p[3], p[5], p[7])  # condition, if statements, else statements
    else:  # if
        p[0] = ('if', p[3], p[5])  # condition, if statements

# Loops
def p_loop(p):
    '''loop : FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement
            | WHILE LPAREN expression RPAREN block_statement'''
    if len(p) == 8:  # while loop
        p[0] = ('while', p[3], p[6])  # condition, statements
    else:  # for loop
        p[0] = ('for', p[3], p[5], p[7], p[10])  # declaration, condition, increment, statements
```
- **Interpreter/Compiler**: The interpreter or compiler processes the parse tree and generates machine code or executes the code directly.
#### Goals of the Language
- Develop a language that can handle continuous data streams.
- Ensure the language can be easily understood and utilized by users without sacrificing capability.
- Provide fast feedback in data processing.

#### Goals for the Thesis
- Develop a working prototype of the Streaming Language.
- Evaluate the language's design and implementation through testing and user feedback.

### Language Design and Implementation

#### Lexical Structure
The lexical components of the Streaming Language include identifiers, keywords, literals, operators, and comments. This design supports a robust structure for programming with clear and concise syntax, aiding in the ease of use and readability.

#### Core Concepts
- **Streams**: At the heart of the language, streams represent sequences of data continuously generated from various sources like sockets and TCP connections. This core concept supports real-time data processing and analysis.
- **Data Types and Structures**: The language supports various data types including integers, floats, arrays, and strings. Advanced types like streams are introduced to manage continuous data flows.


#### Syntax and Functions
The language provides a variety of control structures such as loops and conditional statements, as well as exception handling mechanisms. Functions are defined using a clear syntax that supports arguments and return types, along with function pointers for dynamic behavior.

### Example Use Case

#### Real-time Temperature Processing
The language could be utilized to process a stream of temperature data from a socket, convert it to Celsius, and perform database storage and average temperature calculations. This example highlights the language's ability to handle real-time data streams effectively and perform complex operations like type conversions and average calculations dynamically.
The following is potentially what the code would look like in the Streaming Language. It currently does not work as the interpreter has not been implemented.
```
// Example: Simple stream processing
var dataStream = socket.toStream(); // Create a stream from a socket

fn processData(input: int): int {
    return (input - 32) * 5 / 9; // Convert Fahrenheit to Celsius
}

dataStream.onEntry(processData); // Process each data entry as they arrive
```

#### Parsing output
Input file
```
    var stream_test = socket.toStream();
    var stream_test2 = socket.toStream();
    stream_test >> stream_test2;
```
output AST
```
('program', ('declaration', 'var', ('declaration_base', 'stream_test', None, (('.toStream()', 'socket'),)), ('declaration', 'var', ('declaration_base', 'stream_test2', None, (('.toStream()', 'socket'),))), (('>>', 'stream_test', 'stream_test2'),)))
```
output AST pretty printed
```
('program',
 |('declaration',
 |  |'var',
 |  | |('declaration_base', 'stream_test', None, (('.toStream()', 'socket'),)),
 |('declaration',
 |  |'var',
 |  | |('declaration_base', 'stream_test2', None, (('.toStream()', 'socket'),)),
 |(('>>', 'stream_test', 'stream_test2'),))))
### Progress and Challenges

#### Current Progress
- Basic syntax and structure of the language have been implemented, including core data types and operations. (Still need to fix different lambda cases)
- Parser and Lexer components are currently functional, supporting the processing of language statements and expressions.
- Need to start a refactor to prepare for creation of interpreter component.

#### Challenges and Solutions
- **Challenge**: Keep scope as small as possible to avoid feature creep.
- **Solution**: Focus on core language features and design principles to maintain simplicity and usability. (For instance the original design had a lot of features that were not necessary for the core language such as threading and object oriented programming.)
- **Challenge**: Using python to develop the language, which is not the best language for this type of project, yet it is the language I am most comfortable with such a big project.
- **Solution**: Utilize Python's flexibility and extensive libraries to develop the language quickly, focusing on the core concepts and functionality first before considering performance optimizations. (Once the language works, I can decide if I want to move any segments to a faster language.)

#### Next Steps
- Refactor the codebase IOT add more information associated with the generated AST for use in the interpreter. (Currently the AST is very basic and does not contain much information. While it seems useable I would like more information to make the interpreter easier to write. :) )
- Refactor the parser IOT add more capable rules. IE handling of constant arithmatic during parsing, and handling of function calls.
- Begin work on the interpreter component to execute the AST generated by the parser.
- Add more tests while I create the interpreter to ensure that the language is functioning as expected.

### Conclusion

The development of the Streaming Language is progressing well, all things considered, I need to have more of a work-school-life balance. 
The core concepts and syntax have been implemented, and the parser and lexer components look functional.
I will continue to focus my efforts on refactoring over the summer with the goal of having a working interpreter by the end of the summer.