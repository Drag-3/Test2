Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ATTACH
    EOF
    EVENT
    NE
    NEWLINE
    STREAM

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement -> declaration
Rule 3     statement -> expression SEMICOLON
Rule 4     statement -> return_statement SEMICOLON
Rule 5     statement -> control_flow
Rule 6     statement -> assignment SEMICOLON
Rule 7     statement_list -> statement
Rule 8     statement_list -> statement_list statement
Rule 9     function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN
Rule 10    opt_arg_list -> arg_list
Rule 11    opt_arg_list -> empty
Rule 12    arg_list -> expression
Rule 13    arg_list -> arg_list COMMA expression
Rule 14    function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement
Rule 15    function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement
Rule 16    return_statement -> RETURN expression
Rule 17    block_statement -> LBRACE statement_list RBRACE
Rule 18    lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement
Rule 19    lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
Rule 20    lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement
Rule 21    lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
Rule 22    opt_param_list -> param_list
Rule 23    opt_param_list -> empty
Rule 24    param_list -> param
Rule 25    param_list -> param_list COMMA param
Rule 26    param -> IDENTIFIER
Rule 27    param -> IDENTIFIER typehint
Rule 28    declaration -> VAR declaration_base SEMICOLON
Rule 29    declaration -> CONST declaration_base SEMICOLON
Rule 30    declaration -> function_definition
Rule 31    declaration_base -> IDENTIFIER
Rule 32    declaration_base -> IDENTIFIER ASSIGN expression
Rule 33    declaration_base -> IDENTIFIER typehint
Rule 34    declaration_base -> IDENTIFIER typehint ASSIGN expression
Rule 35    typehint -> TYPEHINTCOLON type
Rule 36    type -> SINT
Rule 37    type -> SFLOAT
Rule 38    type -> SSTRING
Rule 39    type -> SBOOL
Rule 40    type -> SSTREAM
Rule 41    type -> SEVENT
Rule 42    ptype -> INT
Rule 43    ptype -> FLOAT
Rule 44    ptype -> STRING
Rule 45    ptype -> TRUE
Rule 46    ptype -> FALSE
Rule 47    binary_arithmetic_operation_rest -> PLUS expression
Rule 48    binary_arithmetic_operation_rest -> MINUS expression
Rule 49    binary_arithmetic_operation_rest -> MULTIPLY expression
Rule 50    binary_arithmetic_operation_rest -> DIVIDE expression
Rule 51    binary_arithmetic_operation -> expression binary_arithmetic_operation_rest
Rule 52    binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest
Rule 53    unary_arithmetic_operation -> MINUS expression
Rule 54    unary_arithmetic_operation -> PLUS expression
Rule 55    binary_logic_operation -> expression binary_logic_operation_rest
Rule 56    binary_logic_operation -> ptype binary_logic_operation_rest
Rule 57    binary_logic_operation_rest -> EQUALS ptype
Rule 58    binary_logic_operation_rest -> GT ptype
Rule 59    binary_logic_operation_rest -> LT ptype
Rule 60    binary_logic_operation_rest -> GE ptype
Rule 61    binary_logic_operation_rest -> LE ptype
Rule 62    binary_logic_operation_rest -> AND ptype
Rule 63    binary_logic_operation_rest -> OR ptype
Rule 64    binary_logic_operation_rest -> EQUALS expression
Rule 65    binary_logic_operation_rest -> GT expression
Rule 66    binary_logic_operation_rest -> LT expression
Rule 67    binary_logic_operation_rest -> GE expression
Rule 68    binary_logic_operation_rest -> LE expression
Rule 69    binary_logic_operation_rest -> AND expression
Rule 70    binary_logic_operation_rest -> OR expression
Rule 71    unary_logic_operation -> NOT expression
Rule 72    logic_expression -> binary_logic_operation
Rule 73    logic_expression -> unary_logic_operation
Rule 74    function_call_expression -> function_call
Rule 75    object_call_expression -> expression CALL expression
Rule 76    stream_operation -> unary_stream_operation
Rule 77    stream_operation -> binary_stream_operation
Rule 78    stream_operation -> special_stream_operation
Rule 79    unary_stream_operation -> IDENTIFIER TO_STREAM
Rule 80    binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER
Rule 81    binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER
Rule 82    binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER
Rule 83    binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER
Rule 84    special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
Rule 85    special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN
Rule 86    special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN
Rule 87    simple_expression -> ptype
Rule 88    simple_expression -> type
Rule 89    simple_expression -> IDENTIFIER
Rule 90    simple_expression -> LPAREN expression RPAREN
Rule 91    simple_expression -> lambda_function
Rule 92    complex_expression -> binary_arithmetic_operation
Rule 93    complex_expression -> unary_arithmetic_operation
Rule 94    complex_expression -> logic_expression
Rule 95    complex_expression -> function_call_expression
Rule 96    complex_expression -> object_call_expression
Rule 97    complex_expression -> stream_operation
Rule 98    expression -> simple_expression
Rule 99    expression -> complex_expression
Rule 100   control_flow -> conditional
Rule 101   control_flow -> loop
Rule 102   conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement
Rule 103   conditional -> IF LPAREN expression RPAREN block_statement
Rule 104   loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement
Rule 105   loop -> WHILE LPAREN expression RPAREN block_statement
Rule 106   assignment -> IDENTIFIER ASSIGN expression
Rule 107   empty -> <empty>

Terminals, with rules where they appear

AND                  : 62 69
ASSIGN               : 32 34 106
ATTACH               : 
CALL                 : 75
CHAIN                : 80
COMMA                : 13 25
CONST                : 29
DIVIDE               : 50
ELSE                 : 102
EOF                  : 
EQUALS               : 57 64
EVENT                : 
FALSE                : 46
FEEDBACK             : 83
FILTEROP             : 84
FLOAT                : 43
FN                   : 14 15 18 19
FOR                  : 104
GE                   : 60 67
GT                   : 58 65
IDENTIFIER           : 9 14 15 26 27 31 32 33 34 79 80 80 81 81 82 82 83 83 84 85 86 89 106
IF                   : 102 103
INT                  : 42
LAMBDA               : 18 19 20 21
LBRACE               : 17
LE                   : 61 68
LPAREN               : 9 14 15 18 19 20 21 84 85 86 90 102 103 104 105
LT                   : 59 66
MAP                  : 85
MINUS                : 48 53
MULTIPLY             : 49
NE                   : 
NEWLINE              : 
NOT                  : 71
OR                   : 63 70
PLUS                 : 47 54
RBRACE               : 17
REDUCE               : 86
RETURN               : 16
RPAREN               : 9 14 15 18 19 20 21 84 85 86 90 102 103 104 105
SBOOL                : 39
SEMICOLON            : 3 4 6 28 29 104 104
SEVENT               : 41
SFLOAT               : 37
SINT                 : 36
SSTREAM              : 40
SSTRING              : 38
STREAM               : 
STREAMMERGE          : 82
STREAMSPLIT          : 81
STRING               : 44
TO_STREAM            : 79
TRUE                 : 45
TYPEHINTCOLON        : 35
VAR                  : 28
WHILE                : 105
error                : 

Nonterminals, with rules where they appear

arg_list             : 10 13
assignment           : 6
binary_arithmetic_operation : 92
binary_arithmetic_operation_rest : 51 52
binary_logic_operation : 72
binary_logic_operation_rest : 55 56
binary_stream_operation : 77
block_statement      : 14 15 18 19 20 21 102 102 103 104 105
complex_expression   : 99
conditional          : 100
control_flow         : 5
declaration          : 2 104
declaration_base     : 28 29
empty                : 11 23
expression           : 3 12 13 16 32 34 47 48 49 50 51 53 54 55 64 65 66 67 68 69 70 71 75 75 90 102 103 104 104 105 106
function_call        : 74
function_call_expression : 95
function_definition  : 30
lambda_function      : 91
logic_expression     : 84 85 86 94
loop                 : 101
object_call_expression : 96
opt_arg_list         : 9
opt_param_list       : 14 15 18 19 20 21
param                : 24 25
param_list           : 22 25
program              : 0
ptype                : 52 56 57 58 59 60 61 62 63 87
return_statement     : 4
simple_expression    : 98
special_stream_operation : 78
statement            : 7 8
statement_list       : 1 8 17
stream_operation     : 97
type                 : 35 88
typehint             : 15 19 21 27 33 34
unary_arithmetic_operation : 93
unary_logic_operation : 73
unary_stream_operation : 76

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (7) statement_list -> . statement
    (8) statement_list -> . statement_list statement
    (2) statement -> . declaration
    (3) statement -> . expression SEMICOLON
    (4) statement -> . return_statement SEMICOLON
    (5) statement -> . control_flow
    (6) statement -> . assignment SEMICOLON
    (28) declaration -> . VAR declaration_base SEMICOLON
    (29) declaration -> . CONST declaration_base SEMICOLON
    (30) declaration -> . function_definition
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (16) return_statement -> . RETURN expression
    (100) control_flow -> . conditional
    (101) control_flow -> . loop
    (106) assignment -> . IDENTIFIER ASSIGN expression
    (14) function_definition -> . FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement
    (15) function_definition -> . FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (102) conditional -> . IF LPAREN expression RPAREN block_statement ELSE block_statement
    (103) conditional -> . IF LPAREN expression RPAREN block_statement
    (104) loop -> . FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement
    (105) loop -> . WHILE LPAREN expression RPAREN block_statement
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    VAR             shift and go to state 9
    CONST           shift and go to state 10
    RETURN          shift and go to state 14
    IDENTIFIER      shift and go to state 17
    FN              shift and go to state 18
    LPAREN          shift and go to state 19
    IF              shift and go to state 29
    FOR             shift and go to state 30
    WHILE           shift and go to state 31
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    expression                     shift and go to state 5
    return_statement               shift and go to state 6
    control_flow                   shift and go to state 7
    assignment                     shift and go to state 8
    function_definition            shift and go to state 11
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    conditional                    shift and go to state 15
    loop                           shift and go to state 16
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (8) statement_list -> statement_list . statement
    (2) statement -> . declaration
    (3) statement -> . expression SEMICOLON
    (4) statement -> . return_statement SEMICOLON
    (5) statement -> . control_flow
    (6) statement -> . assignment SEMICOLON
    (28) declaration -> . VAR declaration_base SEMICOLON
    (29) declaration -> . CONST declaration_base SEMICOLON
    (30) declaration -> . function_definition
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (16) return_statement -> . RETURN expression
    (100) control_flow -> . conditional
    (101) control_flow -> . loop
    (106) assignment -> . IDENTIFIER ASSIGN expression
    (14) function_definition -> . FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement
    (15) function_definition -> . FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (102) conditional -> . IF LPAREN expression RPAREN block_statement ELSE block_statement
    (103) conditional -> . IF LPAREN expression RPAREN block_statement
    (104) loop -> . FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement
    (105) loop -> . WHILE LPAREN expression RPAREN block_statement
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    $end            reduce using rule 1 (program -> statement_list .)
    VAR             shift and go to state 9
    CONST           shift and go to state 10
    RETURN          shift and go to state 14
    IDENTIFIER      shift and go to state 17
    FN              shift and go to state 18
    LPAREN          shift and go to state 19
    IF              shift and go to state 29
    FOR             shift and go to state 30
    WHILE           shift and go to state 31
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    statement                      shift and go to state 52
    declaration                    shift and go to state 4
    expression                     shift and go to state 5
    return_statement               shift and go to state 6
    control_flow                   shift and go to state 7
    assignment                     shift and go to state 8
    function_definition            shift and go to state 11
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    conditional                    shift and go to state 15
    loop                           shift and go to state 16
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 3

    (7) statement_list -> statement .

    VAR             reduce using rule 7 (statement_list -> statement .)
    CONST           reduce using rule 7 (statement_list -> statement .)
    RETURN          reduce using rule 7 (statement_list -> statement .)
    IDENTIFIER      reduce using rule 7 (statement_list -> statement .)
    FN              reduce using rule 7 (statement_list -> statement .)
    LPAREN          reduce using rule 7 (statement_list -> statement .)
    IF              reduce using rule 7 (statement_list -> statement .)
    FOR             reduce using rule 7 (statement_list -> statement .)
    WHILE           reduce using rule 7 (statement_list -> statement .)
    INT             reduce using rule 7 (statement_list -> statement .)
    FLOAT           reduce using rule 7 (statement_list -> statement .)
    STRING          reduce using rule 7 (statement_list -> statement .)
    TRUE            reduce using rule 7 (statement_list -> statement .)
    FALSE           reduce using rule 7 (statement_list -> statement .)
    SINT            reduce using rule 7 (statement_list -> statement .)
    SFLOAT          reduce using rule 7 (statement_list -> statement .)
    SSTRING         reduce using rule 7 (statement_list -> statement .)
    SBOOL           reduce using rule 7 (statement_list -> statement .)
    SSTREAM         reduce using rule 7 (statement_list -> statement .)
    SEVENT          reduce using rule 7 (statement_list -> statement .)
    MINUS           reduce using rule 7 (statement_list -> statement .)
    PLUS            reduce using rule 7 (statement_list -> statement .)
    NOT             reduce using rule 7 (statement_list -> statement .)
    $end            reduce using rule 7 (statement_list -> statement .)
    RBRACE          reduce using rule 7 (statement_list -> statement .)


state 4

    (2) statement -> declaration .

    VAR             reduce using rule 2 (statement -> declaration .)
    CONST           reduce using rule 2 (statement -> declaration .)
    RETURN          reduce using rule 2 (statement -> declaration .)
    IDENTIFIER      reduce using rule 2 (statement -> declaration .)
    FN              reduce using rule 2 (statement -> declaration .)
    LPAREN          reduce using rule 2 (statement -> declaration .)
    IF              reduce using rule 2 (statement -> declaration .)
    FOR             reduce using rule 2 (statement -> declaration .)
    WHILE           reduce using rule 2 (statement -> declaration .)
    INT             reduce using rule 2 (statement -> declaration .)
    FLOAT           reduce using rule 2 (statement -> declaration .)
    STRING          reduce using rule 2 (statement -> declaration .)
    TRUE            reduce using rule 2 (statement -> declaration .)
    FALSE           reduce using rule 2 (statement -> declaration .)
    SINT            reduce using rule 2 (statement -> declaration .)
    SFLOAT          reduce using rule 2 (statement -> declaration .)
    SSTRING         reduce using rule 2 (statement -> declaration .)
    SBOOL           reduce using rule 2 (statement -> declaration .)
    SSTREAM         reduce using rule 2 (statement -> declaration .)
    SEVENT          reduce using rule 2 (statement -> declaration .)
    MINUS           reduce using rule 2 (statement -> declaration .)
    PLUS            reduce using rule 2 (statement -> declaration .)
    NOT             reduce using rule 2 (statement -> declaration .)
    $end            reduce using rule 2 (statement -> declaration .)
    RBRACE          reduce using rule 2 (statement -> declaration .)


state 5

    (3) statement -> expression . SEMICOLON
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    SEMICOLON       shift and go to state 53
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 6

    (4) statement -> return_statement . SEMICOLON

    SEMICOLON       shift and go to state 68


state 7

    (5) statement -> control_flow .

    VAR             reduce using rule 5 (statement -> control_flow .)
    CONST           reduce using rule 5 (statement -> control_flow .)
    RETURN          reduce using rule 5 (statement -> control_flow .)
    IDENTIFIER      reduce using rule 5 (statement -> control_flow .)
    FN              reduce using rule 5 (statement -> control_flow .)
    LPAREN          reduce using rule 5 (statement -> control_flow .)
    IF              reduce using rule 5 (statement -> control_flow .)
    FOR             reduce using rule 5 (statement -> control_flow .)
    WHILE           reduce using rule 5 (statement -> control_flow .)
    INT             reduce using rule 5 (statement -> control_flow .)
    FLOAT           reduce using rule 5 (statement -> control_flow .)
    STRING          reduce using rule 5 (statement -> control_flow .)
    TRUE            reduce using rule 5 (statement -> control_flow .)
    FALSE           reduce using rule 5 (statement -> control_flow .)
    SINT            reduce using rule 5 (statement -> control_flow .)
    SFLOAT          reduce using rule 5 (statement -> control_flow .)
    SSTRING         reduce using rule 5 (statement -> control_flow .)
    SBOOL           reduce using rule 5 (statement -> control_flow .)
    SSTREAM         reduce using rule 5 (statement -> control_flow .)
    SEVENT          reduce using rule 5 (statement -> control_flow .)
    MINUS           reduce using rule 5 (statement -> control_flow .)
    PLUS            reduce using rule 5 (statement -> control_flow .)
    NOT             reduce using rule 5 (statement -> control_flow .)
    $end            reduce using rule 5 (statement -> control_flow .)
    RBRACE          reduce using rule 5 (statement -> control_flow .)


state 8

    (6) statement -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 69


state 9

    (28) declaration -> VAR . declaration_base SEMICOLON
    (31) declaration_base -> . IDENTIFIER
    (32) declaration_base -> . IDENTIFIER ASSIGN expression
    (33) declaration_base -> . IDENTIFIER typehint
    (34) declaration_base -> . IDENTIFIER typehint ASSIGN expression

    IDENTIFIER      shift and go to state 71

    declaration_base               shift and go to state 70

state 10

    (29) declaration -> CONST . declaration_base SEMICOLON
    (31) declaration_base -> . IDENTIFIER
    (32) declaration_base -> . IDENTIFIER ASSIGN expression
    (33) declaration_base -> . IDENTIFIER typehint
    (34) declaration_base -> . IDENTIFIER typehint ASSIGN expression

    IDENTIFIER      shift and go to state 71

    declaration_base               shift and go to state 72

state 11

    (30) declaration -> function_definition .

    VAR             reduce using rule 30 (declaration -> function_definition .)
    CONST           reduce using rule 30 (declaration -> function_definition .)
    RETURN          reduce using rule 30 (declaration -> function_definition .)
    IDENTIFIER      reduce using rule 30 (declaration -> function_definition .)
    FN              reduce using rule 30 (declaration -> function_definition .)
    LPAREN          reduce using rule 30 (declaration -> function_definition .)
    IF              reduce using rule 30 (declaration -> function_definition .)
    FOR             reduce using rule 30 (declaration -> function_definition .)
    WHILE           reduce using rule 30 (declaration -> function_definition .)
    INT             reduce using rule 30 (declaration -> function_definition .)
    FLOAT           reduce using rule 30 (declaration -> function_definition .)
    STRING          reduce using rule 30 (declaration -> function_definition .)
    TRUE            reduce using rule 30 (declaration -> function_definition .)
    FALSE           reduce using rule 30 (declaration -> function_definition .)
    SINT            reduce using rule 30 (declaration -> function_definition .)
    SFLOAT          reduce using rule 30 (declaration -> function_definition .)
    SSTRING         reduce using rule 30 (declaration -> function_definition .)
    SBOOL           reduce using rule 30 (declaration -> function_definition .)
    SSTREAM         reduce using rule 30 (declaration -> function_definition .)
    SEVENT          reduce using rule 30 (declaration -> function_definition .)
    MINUS           reduce using rule 30 (declaration -> function_definition .)
    PLUS            reduce using rule 30 (declaration -> function_definition .)
    NOT             reduce using rule 30 (declaration -> function_definition .)
    $end            reduce using rule 30 (declaration -> function_definition .)
    SEMICOLON       reduce using rule 30 (declaration -> function_definition .)
    RBRACE          reduce using rule 30 (declaration -> function_definition .)


state 12

    (98) expression -> simple_expression .

    SEMICOLON       reduce using rule 98 (expression -> simple_expression .)
    CALL            reduce using rule 98 (expression -> simple_expression .)
    PLUS            reduce using rule 98 (expression -> simple_expression .)
    MINUS           reduce using rule 98 (expression -> simple_expression .)
    MULTIPLY        reduce using rule 98 (expression -> simple_expression .)
    DIVIDE          reduce using rule 98 (expression -> simple_expression .)
    EQUALS          reduce using rule 98 (expression -> simple_expression .)
    GT              reduce using rule 98 (expression -> simple_expression .)
    LT              reduce using rule 98 (expression -> simple_expression .)
    GE              reduce using rule 98 (expression -> simple_expression .)
    LE              reduce using rule 98 (expression -> simple_expression .)
    AND             reduce using rule 98 (expression -> simple_expression .)
    OR              reduce using rule 98 (expression -> simple_expression .)
    RPAREN          reduce using rule 98 (expression -> simple_expression .)
    COMMA           reduce using rule 98 (expression -> simple_expression .)


state 13

    (99) expression -> complex_expression .

    SEMICOLON       reduce using rule 99 (expression -> complex_expression .)
    CALL            reduce using rule 99 (expression -> complex_expression .)
    PLUS            reduce using rule 99 (expression -> complex_expression .)
    MINUS           reduce using rule 99 (expression -> complex_expression .)
    MULTIPLY        reduce using rule 99 (expression -> complex_expression .)
    DIVIDE          reduce using rule 99 (expression -> complex_expression .)
    EQUALS          reduce using rule 99 (expression -> complex_expression .)
    GT              reduce using rule 99 (expression -> complex_expression .)
    LT              reduce using rule 99 (expression -> complex_expression .)
    GE              reduce using rule 99 (expression -> complex_expression .)
    LE              reduce using rule 99 (expression -> complex_expression .)
    AND             reduce using rule 99 (expression -> complex_expression .)
    OR              reduce using rule 99 (expression -> complex_expression .)
    RPAREN          reduce using rule 99 (expression -> complex_expression .)
    COMMA           reduce using rule 99 (expression -> complex_expression .)


state 14

    (16) return_statement -> RETURN . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 73
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 15

    (100) control_flow -> conditional .

    VAR             reduce using rule 100 (control_flow -> conditional .)
    CONST           reduce using rule 100 (control_flow -> conditional .)
    RETURN          reduce using rule 100 (control_flow -> conditional .)
    IDENTIFIER      reduce using rule 100 (control_flow -> conditional .)
    FN              reduce using rule 100 (control_flow -> conditional .)
    LPAREN          reduce using rule 100 (control_flow -> conditional .)
    IF              reduce using rule 100 (control_flow -> conditional .)
    FOR             reduce using rule 100 (control_flow -> conditional .)
    WHILE           reduce using rule 100 (control_flow -> conditional .)
    INT             reduce using rule 100 (control_flow -> conditional .)
    FLOAT           reduce using rule 100 (control_flow -> conditional .)
    STRING          reduce using rule 100 (control_flow -> conditional .)
    TRUE            reduce using rule 100 (control_flow -> conditional .)
    FALSE           reduce using rule 100 (control_flow -> conditional .)
    SINT            reduce using rule 100 (control_flow -> conditional .)
    SFLOAT          reduce using rule 100 (control_flow -> conditional .)
    SSTRING         reduce using rule 100 (control_flow -> conditional .)
    SBOOL           reduce using rule 100 (control_flow -> conditional .)
    SSTREAM         reduce using rule 100 (control_flow -> conditional .)
    SEVENT          reduce using rule 100 (control_flow -> conditional .)
    MINUS           reduce using rule 100 (control_flow -> conditional .)
    PLUS            reduce using rule 100 (control_flow -> conditional .)
    NOT             reduce using rule 100 (control_flow -> conditional .)
    $end            reduce using rule 100 (control_flow -> conditional .)
    RBRACE          reduce using rule 100 (control_flow -> conditional .)


state 16

    (101) control_flow -> loop .

    VAR             reduce using rule 101 (control_flow -> loop .)
    CONST           reduce using rule 101 (control_flow -> loop .)
    RETURN          reduce using rule 101 (control_flow -> loop .)
    IDENTIFIER      reduce using rule 101 (control_flow -> loop .)
    FN              reduce using rule 101 (control_flow -> loop .)
    LPAREN          reduce using rule 101 (control_flow -> loop .)
    IF              reduce using rule 101 (control_flow -> loop .)
    FOR             reduce using rule 101 (control_flow -> loop .)
    WHILE           reduce using rule 101 (control_flow -> loop .)
    INT             reduce using rule 101 (control_flow -> loop .)
    FLOAT           reduce using rule 101 (control_flow -> loop .)
    STRING          reduce using rule 101 (control_flow -> loop .)
    TRUE            reduce using rule 101 (control_flow -> loop .)
    FALSE           reduce using rule 101 (control_flow -> loop .)
    SINT            reduce using rule 101 (control_flow -> loop .)
    SFLOAT          reduce using rule 101 (control_flow -> loop .)
    SSTRING         reduce using rule 101 (control_flow -> loop .)
    SBOOL           reduce using rule 101 (control_flow -> loop .)
    SSTREAM         reduce using rule 101 (control_flow -> loop .)
    SEVENT          reduce using rule 101 (control_flow -> loop .)
    MINUS           reduce using rule 101 (control_flow -> loop .)
    PLUS            reduce using rule 101 (control_flow -> loop .)
    NOT             reduce using rule 101 (control_flow -> loop .)
    $end            reduce using rule 101 (control_flow -> loop .)
    RBRACE          reduce using rule 101 (control_flow -> loop .)


state 17

    (106) assignment -> IDENTIFIER . ASSIGN expression
    (89) simple_expression -> IDENTIFIER .
    (9) function_call -> IDENTIFIER . LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> IDENTIFIER . TO_STREAM
    (80) binary_stream_operation -> IDENTIFIER . CHAIN IDENTIFIER
    (81) binary_stream_operation -> IDENTIFIER . STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> IDENTIFIER . STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> IDENTIFIER . FEEDBACK IDENTIFIER
    (84) special_stream_operation -> IDENTIFIER . FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> IDENTIFIER . MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> IDENTIFIER . REDUCE LPAREN logic_expression RPAREN

    ASSIGN          shift and go to state 76
    SEMICOLON       reduce using rule 89 (simple_expression -> IDENTIFIER .)
    CALL            reduce using rule 89 (simple_expression -> IDENTIFIER .)
    PLUS            reduce using rule 89 (simple_expression -> IDENTIFIER .)
    MINUS           reduce using rule 89 (simple_expression -> IDENTIFIER .)
    MULTIPLY        reduce using rule 89 (simple_expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 89 (simple_expression -> IDENTIFIER .)
    EQUALS          reduce using rule 89 (simple_expression -> IDENTIFIER .)
    GT              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    LT              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    GE              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    LE              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    AND             reduce using rule 89 (simple_expression -> IDENTIFIER .)
    OR              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    LPAREN          shift and go to state 77
    TO_STREAM       shift and go to state 78
    CHAIN           shift and go to state 79
    STREAMSPLIT     shift and go to state 80
    STREAMMERGE     shift and go to state 81
    FEEDBACK        shift and go to state 82
    FILTEROP        shift and go to state 83
    MAP             shift and go to state 84
    REDUCE          shift and go to state 85


state 18

    (14) function_definition -> FN . IDENTIFIER LPAREN opt_param_list RPAREN block_statement
    (15) function_definition -> FN . IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement
    (18) lambda_function -> FN . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> FN . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement

    IDENTIFIER      shift and go to state 86
    LPAREN          shift and go to state 87


state 19

    (90) simple_expression -> LPAREN . expression RPAREN
    (20) lambda_function -> LPAREN . opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> LPAREN . opt_param_list RPAREN typehint LAMBDA block_statement
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (22) opt_param_list -> . param_list
    (23) opt_param_list -> . empty
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (24) param_list -> . param
    (25) param_list -> . param_list COMMA param
    (107) empty -> .
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (26) param -> . IDENTIFIER
    (27) param -> . IDENTIFIER typehint
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 92
    LPAREN          shift and go to state 19
    RPAREN          reduce using rule 107 (empty -> .)
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 88
    opt_param_list                 shift and go to state 89
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    param_list                     shift and go to state 90
    empty                          shift and go to state 91
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    param                          shift and go to state 93
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 20

    (87) simple_expression -> ptype .
    (52) binary_arithmetic_operation -> ptype . binary_arithmetic_operation_rest
    (56) binary_logic_operation -> ptype . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 87 (simple_expression -> ptype .)
    CALL            reduce using rule 87 (simple_expression -> ptype .)
    RPAREN          reduce using rule 87 (simple_expression -> ptype .)
    COMMA           reduce using rule 87 (simple_expression -> ptype .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MINUS           [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MULTIPLY        [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! DIVIDE          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! EQUALS          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! AND             [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! OR              [ reduce using rule 87 (simple_expression -> ptype .) ]

    binary_arithmetic_operation_rest shift and go to state 94
    binary_logic_operation_rest    shift and go to state 95

state 21

    (88) simple_expression -> type .

    SEMICOLON       reduce using rule 88 (simple_expression -> type .)
    CALL            reduce using rule 88 (simple_expression -> type .)
    PLUS            reduce using rule 88 (simple_expression -> type .)
    MINUS           reduce using rule 88 (simple_expression -> type .)
    MULTIPLY        reduce using rule 88 (simple_expression -> type .)
    DIVIDE          reduce using rule 88 (simple_expression -> type .)
    EQUALS          reduce using rule 88 (simple_expression -> type .)
    GT              reduce using rule 88 (simple_expression -> type .)
    LT              reduce using rule 88 (simple_expression -> type .)
    GE              reduce using rule 88 (simple_expression -> type .)
    LE              reduce using rule 88 (simple_expression -> type .)
    AND             reduce using rule 88 (simple_expression -> type .)
    OR              reduce using rule 88 (simple_expression -> type .)
    RPAREN          reduce using rule 88 (simple_expression -> type .)
    COMMA           reduce using rule 88 (simple_expression -> type .)


state 22

    (91) simple_expression -> lambda_function .

    SEMICOLON       reduce using rule 91 (simple_expression -> lambda_function .)
    CALL            reduce using rule 91 (simple_expression -> lambda_function .)
    PLUS            reduce using rule 91 (simple_expression -> lambda_function .)
    MINUS           reduce using rule 91 (simple_expression -> lambda_function .)
    MULTIPLY        reduce using rule 91 (simple_expression -> lambda_function .)
    DIVIDE          reduce using rule 91 (simple_expression -> lambda_function .)
    EQUALS          reduce using rule 91 (simple_expression -> lambda_function .)
    GT              reduce using rule 91 (simple_expression -> lambda_function .)
    LT              reduce using rule 91 (simple_expression -> lambda_function .)
    GE              reduce using rule 91 (simple_expression -> lambda_function .)
    LE              reduce using rule 91 (simple_expression -> lambda_function .)
    AND             reduce using rule 91 (simple_expression -> lambda_function .)
    OR              reduce using rule 91 (simple_expression -> lambda_function .)
    RPAREN          reduce using rule 91 (simple_expression -> lambda_function .)
    COMMA           reduce using rule 91 (simple_expression -> lambda_function .)


state 23

    (92) complex_expression -> binary_arithmetic_operation .

    SEMICOLON       reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    CALL            reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    PLUS            reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    MINUS           reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    MULTIPLY        reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    DIVIDE          reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    EQUALS          reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    GT              reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    LT              reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    GE              reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    LE              reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    AND             reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    OR              reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    RPAREN          reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)
    COMMA           reduce using rule 92 (complex_expression -> binary_arithmetic_operation .)


state 24

    (93) complex_expression -> unary_arithmetic_operation .

    SEMICOLON       reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    CALL            reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    PLUS            reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    MINUS           reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    MULTIPLY        reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    DIVIDE          reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    EQUALS          reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    GT              reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    LT              reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    GE              reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    LE              reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    AND             reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    OR              reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    RPAREN          reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)
    COMMA           reduce using rule 93 (complex_expression -> unary_arithmetic_operation .)


state 25

    (94) complex_expression -> logic_expression .

    SEMICOLON       reduce using rule 94 (complex_expression -> logic_expression .)
    CALL            reduce using rule 94 (complex_expression -> logic_expression .)
    PLUS            reduce using rule 94 (complex_expression -> logic_expression .)
    MINUS           reduce using rule 94 (complex_expression -> logic_expression .)
    MULTIPLY        reduce using rule 94 (complex_expression -> logic_expression .)
    DIVIDE          reduce using rule 94 (complex_expression -> logic_expression .)
    EQUALS          reduce using rule 94 (complex_expression -> logic_expression .)
    GT              reduce using rule 94 (complex_expression -> logic_expression .)
    LT              reduce using rule 94 (complex_expression -> logic_expression .)
    GE              reduce using rule 94 (complex_expression -> logic_expression .)
    LE              reduce using rule 94 (complex_expression -> logic_expression .)
    AND             reduce using rule 94 (complex_expression -> logic_expression .)
    OR              reduce using rule 94 (complex_expression -> logic_expression .)
    RPAREN          reduce using rule 94 (complex_expression -> logic_expression .)
    COMMA           reduce using rule 94 (complex_expression -> logic_expression .)


state 26

    (95) complex_expression -> function_call_expression .

    SEMICOLON       reduce using rule 95 (complex_expression -> function_call_expression .)
    CALL            reduce using rule 95 (complex_expression -> function_call_expression .)
    PLUS            reduce using rule 95 (complex_expression -> function_call_expression .)
    MINUS           reduce using rule 95 (complex_expression -> function_call_expression .)
    MULTIPLY        reduce using rule 95 (complex_expression -> function_call_expression .)
    DIVIDE          reduce using rule 95 (complex_expression -> function_call_expression .)
    EQUALS          reduce using rule 95 (complex_expression -> function_call_expression .)
    GT              reduce using rule 95 (complex_expression -> function_call_expression .)
    LT              reduce using rule 95 (complex_expression -> function_call_expression .)
    GE              reduce using rule 95 (complex_expression -> function_call_expression .)
    LE              reduce using rule 95 (complex_expression -> function_call_expression .)
    AND             reduce using rule 95 (complex_expression -> function_call_expression .)
    OR              reduce using rule 95 (complex_expression -> function_call_expression .)
    RPAREN          reduce using rule 95 (complex_expression -> function_call_expression .)
    COMMA           reduce using rule 95 (complex_expression -> function_call_expression .)


state 27

    (96) complex_expression -> object_call_expression .

    SEMICOLON       reduce using rule 96 (complex_expression -> object_call_expression .)
    CALL            reduce using rule 96 (complex_expression -> object_call_expression .)
    PLUS            reduce using rule 96 (complex_expression -> object_call_expression .)
    MINUS           reduce using rule 96 (complex_expression -> object_call_expression .)
    MULTIPLY        reduce using rule 96 (complex_expression -> object_call_expression .)
    DIVIDE          reduce using rule 96 (complex_expression -> object_call_expression .)
    EQUALS          reduce using rule 96 (complex_expression -> object_call_expression .)
    GT              reduce using rule 96 (complex_expression -> object_call_expression .)
    LT              reduce using rule 96 (complex_expression -> object_call_expression .)
    GE              reduce using rule 96 (complex_expression -> object_call_expression .)
    LE              reduce using rule 96 (complex_expression -> object_call_expression .)
    AND             reduce using rule 96 (complex_expression -> object_call_expression .)
    OR              reduce using rule 96 (complex_expression -> object_call_expression .)
    RPAREN          reduce using rule 96 (complex_expression -> object_call_expression .)
    COMMA           reduce using rule 96 (complex_expression -> object_call_expression .)


state 28

    (97) complex_expression -> stream_operation .

    SEMICOLON       reduce using rule 97 (complex_expression -> stream_operation .)
    CALL            reduce using rule 97 (complex_expression -> stream_operation .)
    PLUS            reduce using rule 97 (complex_expression -> stream_operation .)
    MINUS           reduce using rule 97 (complex_expression -> stream_operation .)
    MULTIPLY        reduce using rule 97 (complex_expression -> stream_operation .)
    DIVIDE          reduce using rule 97 (complex_expression -> stream_operation .)
    EQUALS          reduce using rule 97 (complex_expression -> stream_operation .)
    GT              reduce using rule 97 (complex_expression -> stream_operation .)
    LT              reduce using rule 97 (complex_expression -> stream_operation .)
    GE              reduce using rule 97 (complex_expression -> stream_operation .)
    LE              reduce using rule 97 (complex_expression -> stream_operation .)
    AND             reduce using rule 97 (complex_expression -> stream_operation .)
    OR              reduce using rule 97 (complex_expression -> stream_operation .)
    RPAREN          reduce using rule 97 (complex_expression -> stream_operation .)
    COMMA           reduce using rule 97 (complex_expression -> stream_operation .)


state 29

    (102) conditional -> IF . LPAREN expression RPAREN block_statement ELSE block_statement
    (103) conditional -> IF . LPAREN expression RPAREN block_statement

    LPAREN          shift and go to state 96


state 30

    (104) loop -> FOR . LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement

    LPAREN          shift and go to state 97


state 31

    (105) loop -> WHILE . LPAREN expression RPAREN block_statement

    LPAREN          shift and go to state 98


state 32

    (42) ptype -> INT .

    PLUS            reduce using rule 42 (ptype -> INT .)
    MINUS           reduce using rule 42 (ptype -> INT .)
    MULTIPLY        reduce using rule 42 (ptype -> INT .)
    DIVIDE          reduce using rule 42 (ptype -> INT .)
    EQUALS          reduce using rule 42 (ptype -> INT .)
    GT              reduce using rule 42 (ptype -> INT .)
    LT              reduce using rule 42 (ptype -> INT .)
    GE              reduce using rule 42 (ptype -> INT .)
    LE              reduce using rule 42 (ptype -> INT .)
    AND             reduce using rule 42 (ptype -> INT .)
    OR              reduce using rule 42 (ptype -> INT .)
    SEMICOLON       reduce using rule 42 (ptype -> INT .)
    CALL            reduce using rule 42 (ptype -> INT .)
    RPAREN          reduce using rule 42 (ptype -> INT .)
    COMMA           reduce using rule 42 (ptype -> INT .)


state 33

    (43) ptype -> FLOAT .

    PLUS            reduce using rule 43 (ptype -> FLOAT .)
    MINUS           reduce using rule 43 (ptype -> FLOAT .)
    MULTIPLY        reduce using rule 43 (ptype -> FLOAT .)
    DIVIDE          reduce using rule 43 (ptype -> FLOAT .)
    EQUALS          reduce using rule 43 (ptype -> FLOAT .)
    GT              reduce using rule 43 (ptype -> FLOAT .)
    LT              reduce using rule 43 (ptype -> FLOAT .)
    GE              reduce using rule 43 (ptype -> FLOAT .)
    LE              reduce using rule 43 (ptype -> FLOAT .)
    AND             reduce using rule 43 (ptype -> FLOAT .)
    OR              reduce using rule 43 (ptype -> FLOAT .)
    SEMICOLON       reduce using rule 43 (ptype -> FLOAT .)
    CALL            reduce using rule 43 (ptype -> FLOAT .)
    RPAREN          reduce using rule 43 (ptype -> FLOAT .)
    COMMA           reduce using rule 43 (ptype -> FLOAT .)


state 34

    (44) ptype -> STRING .

    PLUS            reduce using rule 44 (ptype -> STRING .)
    MINUS           reduce using rule 44 (ptype -> STRING .)
    MULTIPLY        reduce using rule 44 (ptype -> STRING .)
    DIVIDE          reduce using rule 44 (ptype -> STRING .)
    EQUALS          reduce using rule 44 (ptype -> STRING .)
    GT              reduce using rule 44 (ptype -> STRING .)
    LT              reduce using rule 44 (ptype -> STRING .)
    GE              reduce using rule 44 (ptype -> STRING .)
    LE              reduce using rule 44 (ptype -> STRING .)
    AND             reduce using rule 44 (ptype -> STRING .)
    OR              reduce using rule 44 (ptype -> STRING .)
    SEMICOLON       reduce using rule 44 (ptype -> STRING .)
    CALL            reduce using rule 44 (ptype -> STRING .)
    RPAREN          reduce using rule 44 (ptype -> STRING .)
    COMMA           reduce using rule 44 (ptype -> STRING .)


state 35

    (45) ptype -> TRUE .

    PLUS            reduce using rule 45 (ptype -> TRUE .)
    MINUS           reduce using rule 45 (ptype -> TRUE .)
    MULTIPLY        reduce using rule 45 (ptype -> TRUE .)
    DIVIDE          reduce using rule 45 (ptype -> TRUE .)
    EQUALS          reduce using rule 45 (ptype -> TRUE .)
    GT              reduce using rule 45 (ptype -> TRUE .)
    LT              reduce using rule 45 (ptype -> TRUE .)
    GE              reduce using rule 45 (ptype -> TRUE .)
    LE              reduce using rule 45 (ptype -> TRUE .)
    AND             reduce using rule 45 (ptype -> TRUE .)
    OR              reduce using rule 45 (ptype -> TRUE .)
    SEMICOLON       reduce using rule 45 (ptype -> TRUE .)
    CALL            reduce using rule 45 (ptype -> TRUE .)
    RPAREN          reduce using rule 45 (ptype -> TRUE .)
    COMMA           reduce using rule 45 (ptype -> TRUE .)


state 36

    (46) ptype -> FALSE .

    PLUS            reduce using rule 46 (ptype -> FALSE .)
    MINUS           reduce using rule 46 (ptype -> FALSE .)
    MULTIPLY        reduce using rule 46 (ptype -> FALSE .)
    DIVIDE          reduce using rule 46 (ptype -> FALSE .)
    EQUALS          reduce using rule 46 (ptype -> FALSE .)
    GT              reduce using rule 46 (ptype -> FALSE .)
    LT              reduce using rule 46 (ptype -> FALSE .)
    GE              reduce using rule 46 (ptype -> FALSE .)
    LE              reduce using rule 46 (ptype -> FALSE .)
    AND             reduce using rule 46 (ptype -> FALSE .)
    OR              reduce using rule 46 (ptype -> FALSE .)
    SEMICOLON       reduce using rule 46 (ptype -> FALSE .)
    CALL            reduce using rule 46 (ptype -> FALSE .)
    RPAREN          reduce using rule 46 (ptype -> FALSE .)
    COMMA           reduce using rule 46 (ptype -> FALSE .)


state 37

    (36) type -> SINT .

    SEMICOLON       reduce using rule 36 (type -> SINT .)
    CALL            reduce using rule 36 (type -> SINT .)
    PLUS            reduce using rule 36 (type -> SINT .)
    MINUS           reduce using rule 36 (type -> SINT .)
    MULTIPLY        reduce using rule 36 (type -> SINT .)
    DIVIDE          reduce using rule 36 (type -> SINT .)
    EQUALS          reduce using rule 36 (type -> SINT .)
    GT              reduce using rule 36 (type -> SINT .)
    LT              reduce using rule 36 (type -> SINT .)
    GE              reduce using rule 36 (type -> SINT .)
    LE              reduce using rule 36 (type -> SINT .)
    AND             reduce using rule 36 (type -> SINT .)
    OR              reduce using rule 36 (type -> SINT .)
    RPAREN          reduce using rule 36 (type -> SINT .)
    COMMA           reduce using rule 36 (type -> SINT .)
    ASSIGN          reduce using rule 36 (type -> SINT .)
    LAMBDA          reduce using rule 36 (type -> SINT .)
    LBRACE          reduce using rule 36 (type -> SINT .)


state 38

    (37) type -> SFLOAT .

    SEMICOLON       reduce using rule 37 (type -> SFLOAT .)
    CALL            reduce using rule 37 (type -> SFLOAT .)
    PLUS            reduce using rule 37 (type -> SFLOAT .)
    MINUS           reduce using rule 37 (type -> SFLOAT .)
    MULTIPLY        reduce using rule 37 (type -> SFLOAT .)
    DIVIDE          reduce using rule 37 (type -> SFLOAT .)
    EQUALS          reduce using rule 37 (type -> SFLOAT .)
    GT              reduce using rule 37 (type -> SFLOAT .)
    LT              reduce using rule 37 (type -> SFLOAT .)
    GE              reduce using rule 37 (type -> SFLOAT .)
    LE              reduce using rule 37 (type -> SFLOAT .)
    AND             reduce using rule 37 (type -> SFLOAT .)
    OR              reduce using rule 37 (type -> SFLOAT .)
    RPAREN          reduce using rule 37 (type -> SFLOAT .)
    COMMA           reduce using rule 37 (type -> SFLOAT .)
    ASSIGN          reduce using rule 37 (type -> SFLOAT .)
    LAMBDA          reduce using rule 37 (type -> SFLOAT .)
    LBRACE          reduce using rule 37 (type -> SFLOAT .)


state 39

    (38) type -> SSTRING .

    SEMICOLON       reduce using rule 38 (type -> SSTRING .)
    CALL            reduce using rule 38 (type -> SSTRING .)
    PLUS            reduce using rule 38 (type -> SSTRING .)
    MINUS           reduce using rule 38 (type -> SSTRING .)
    MULTIPLY        reduce using rule 38 (type -> SSTRING .)
    DIVIDE          reduce using rule 38 (type -> SSTRING .)
    EQUALS          reduce using rule 38 (type -> SSTRING .)
    GT              reduce using rule 38 (type -> SSTRING .)
    LT              reduce using rule 38 (type -> SSTRING .)
    GE              reduce using rule 38 (type -> SSTRING .)
    LE              reduce using rule 38 (type -> SSTRING .)
    AND             reduce using rule 38 (type -> SSTRING .)
    OR              reduce using rule 38 (type -> SSTRING .)
    RPAREN          reduce using rule 38 (type -> SSTRING .)
    COMMA           reduce using rule 38 (type -> SSTRING .)
    ASSIGN          reduce using rule 38 (type -> SSTRING .)
    LAMBDA          reduce using rule 38 (type -> SSTRING .)
    LBRACE          reduce using rule 38 (type -> SSTRING .)


state 40

    (39) type -> SBOOL .

    SEMICOLON       reduce using rule 39 (type -> SBOOL .)
    CALL            reduce using rule 39 (type -> SBOOL .)
    PLUS            reduce using rule 39 (type -> SBOOL .)
    MINUS           reduce using rule 39 (type -> SBOOL .)
    MULTIPLY        reduce using rule 39 (type -> SBOOL .)
    DIVIDE          reduce using rule 39 (type -> SBOOL .)
    EQUALS          reduce using rule 39 (type -> SBOOL .)
    GT              reduce using rule 39 (type -> SBOOL .)
    LT              reduce using rule 39 (type -> SBOOL .)
    GE              reduce using rule 39 (type -> SBOOL .)
    LE              reduce using rule 39 (type -> SBOOL .)
    AND             reduce using rule 39 (type -> SBOOL .)
    OR              reduce using rule 39 (type -> SBOOL .)
    RPAREN          reduce using rule 39 (type -> SBOOL .)
    COMMA           reduce using rule 39 (type -> SBOOL .)
    ASSIGN          reduce using rule 39 (type -> SBOOL .)
    LAMBDA          reduce using rule 39 (type -> SBOOL .)
    LBRACE          reduce using rule 39 (type -> SBOOL .)


state 41

    (40) type -> SSTREAM .

    SEMICOLON       reduce using rule 40 (type -> SSTREAM .)
    CALL            reduce using rule 40 (type -> SSTREAM .)
    PLUS            reduce using rule 40 (type -> SSTREAM .)
    MINUS           reduce using rule 40 (type -> SSTREAM .)
    MULTIPLY        reduce using rule 40 (type -> SSTREAM .)
    DIVIDE          reduce using rule 40 (type -> SSTREAM .)
    EQUALS          reduce using rule 40 (type -> SSTREAM .)
    GT              reduce using rule 40 (type -> SSTREAM .)
    LT              reduce using rule 40 (type -> SSTREAM .)
    GE              reduce using rule 40 (type -> SSTREAM .)
    LE              reduce using rule 40 (type -> SSTREAM .)
    AND             reduce using rule 40 (type -> SSTREAM .)
    OR              reduce using rule 40 (type -> SSTREAM .)
    RPAREN          reduce using rule 40 (type -> SSTREAM .)
    COMMA           reduce using rule 40 (type -> SSTREAM .)
    ASSIGN          reduce using rule 40 (type -> SSTREAM .)
    LAMBDA          reduce using rule 40 (type -> SSTREAM .)
    LBRACE          reduce using rule 40 (type -> SSTREAM .)


state 42

    (41) type -> SEVENT .

    SEMICOLON       reduce using rule 41 (type -> SEVENT .)
    CALL            reduce using rule 41 (type -> SEVENT .)
    PLUS            reduce using rule 41 (type -> SEVENT .)
    MINUS           reduce using rule 41 (type -> SEVENT .)
    MULTIPLY        reduce using rule 41 (type -> SEVENT .)
    DIVIDE          reduce using rule 41 (type -> SEVENT .)
    EQUALS          reduce using rule 41 (type -> SEVENT .)
    GT              reduce using rule 41 (type -> SEVENT .)
    LT              reduce using rule 41 (type -> SEVENT .)
    GE              reduce using rule 41 (type -> SEVENT .)
    LE              reduce using rule 41 (type -> SEVENT .)
    AND             reduce using rule 41 (type -> SEVENT .)
    OR              reduce using rule 41 (type -> SEVENT .)
    RPAREN          reduce using rule 41 (type -> SEVENT .)
    COMMA           reduce using rule 41 (type -> SEVENT .)
    ASSIGN          reduce using rule 41 (type -> SEVENT .)
    LAMBDA          reduce using rule 41 (type -> SEVENT .)
    LBRACE          reduce using rule 41 (type -> SEVENT .)


state 43

    (53) unary_arithmetic_operation -> MINUS . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 99
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 44

    (54) unary_arithmetic_operation -> PLUS . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 100
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 45

    (72) logic_expression -> binary_logic_operation .

    SEMICOLON       reduce using rule 72 (logic_expression -> binary_logic_operation .)
    CALL            reduce using rule 72 (logic_expression -> binary_logic_operation .)
    PLUS            reduce using rule 72 (logic_expression -> binary_logic_operation .)
    MINUS           reduce using rule 72 (logic_expression -> binary_logic_operation .)
    MULTIPLY        reduce using rule 72 (logic_expression -> binary_logic_operation .)
    DIVIDE          reduce using rule 72 (logic_expression -> binary_logic_operation .)
    EQUALS          reduce using rule 72 (logic_expression -> binary_logic_operation .)
    GT              reduce using rule 72 (logic_expression -> binary_logic_operation .)
    LT              reduce using rule 72 (logic_expression -> binary_logic_operation .)
    GE              reduce using rule 72 (logic_expression -> binary_logic_operation .)
    LE              reduce using rule 72 (logic_expression -> binary_logic_operation .)
    AND             reduce using rule 72 (logic_expression -> binary_logic_operation .)
    OR              reduce using rule 72 (logic_expression -> binary_logic_operation .)
    RPAREN          reduce using rule 72 (logic_expression -> binary_logic_operation .)
    COMMA           reduce using rule 72 (logic_expression -> binary_logic_operation .)


state 46

    (73) logic_expression -> unary_logic_operation .

    SEMICOLON       reduce using rule 73 (logic_expression -> unary_logic_operation .)
    CALL            reduce using rule 73 (logic_expression -> unary_logic_operation .)
    PLUS            reduce using rule 73 (logic_expression -> unary_logic_operation .)
    MINUS           reduce using rule 73 (logic_expression -> unary_logic_operation .)
    MULTIPLY        reduce using rule 73 (logic_expression -> unary_logic_operation .)
    DIVIDE          reduce using rule 73 (logic_expression -> unary_logic_operation .)
    EQUALS          reduce using rule 73 (logic_expression -> unary_logic_operation .)
    GT              reduce using rule 73 (logic_expression -> unary_logic_operation .)
    LT              reduce using rule 73 (logic_expression -> unary_logic_operation .)
    GE              reduce using rule 73 (logic_expression -> unary_logic_operation .)
    LE              reduce using rule 73 (logic_expression -> unary_logic_operation .)
    AND             reduce using rule 73 (logic_expression -> unary_logic_operation .)
    OR              reduce using rule 73 (logic_expression -> unary_logic_operation .)
    RPAREN          reduce using rule 73 (logic_expression -> unary_logic_operation .)
    COMMA           reduce using rule 73 (logic_expression -> unary_logic_operation .)


state 47

    (74) function_call_expression -> function_call .

    SEMICOLON       reduce using rule 74 (function_call_expression -> function_call .)
    CALL            reduce using rule 74 (function_call_expression -> function_call .)
    PLUS            reduce using rule 74 (function_call_expression -> function_call .)
    MINUS           reduce using rule 74 (function_call_expression -> function_call .)
    MULTIPLY        reduce using rule 74 (function_call_expression -> function_call .)
    DIVIDE          reduce using rule 74 (function_call_expression -> function_call .)
    EQUALS          reduce using rule 74 (function_call_expression -> function_call .)
    GT              reduce using rule 74 (function_call_expression -> function_call .)
    LT              reduce using rule 74 (function_call_expression -> function_call .)
    GE              reduce using rule 74 (function_call_expression -> function_call .)
    LE              reduce using rule 74 (function_call_expression -> function_call .)
    AND             reduce using rule 74 (function_call_expression -> function_call .)
    OR              reduce using rule 74 (function_call_expression -> function_call .)
    RPAREN          reduce using rule 74 (function_call_expression -> function_call .)
    COMMA           reduce using rule 74 (function_call_expression -> function_call .)


state 48

    (76) stream_operation -> unary_stream_operation .

    SEMICOLON       reduce using rule 76 (stream_operation -> unary_stream_operation .)
    CALL            reduce using rule 76 (stream_operation -> unary_stream_operation .)
    PLUS            reduce using rule 76 (stream_operation -> unary_stream_operation .)
    MINUS           reduce using rule 76 (stream_operation -> unary_stream_operation .)
    MULTIPLY        reduce using rule 76 (stream_operation -> unary_stream_operation .)
    DIVIDE          reduce using rule 76 (stream_operation -> unary_stream_operation .)
    EQUALS          reduce using rule 76 (stream_operation -> unary_stream_operation .)
    GT              reduce using rule 76 (stream_operation -> unary_stream_operation .)
    LT              reduce using rule 76 (stream_operation -> unary_stream_operation .)
    GE              reduce using rule 76 (stream_operation -> unary_stream_operation .)
    LE              reduce using rule 76 (stream_operation -> unary_stream_operation .)
    AND             reduce using rule 76 (stream_operation -> unary_stream_operation .)
    OR              reduce using rule 76 (stream_operation -> unary_stream_operation .)
    RPAREN          reduce using rule 76 (stream_operation -> unary_stream_operation .)
    COMMA           reduce using rule 76 (stream_operation -> unary_stream_operation .)


state 49

    (77) stream_operation -> binary_stream_operation .

    SEMICOLON       reduce using rule 77 (stream_operation -> binary_stream_operation .)
    CALL            reduce using rule 77 (stream_operation -> binary_stream_operation .)
    PLUS            reduce using rule 77 (stream_operation -> binary_stream_operation .)
    MINUS           reduce using rule 77 (stream_operation -> binary_stream_operation .)
    MULTIPLY        reduce using rule 77 (stream_operation -> binary_stream_operation .)
    DIVIDE          reduce using rule 77 (stream_operation -> binary_stream_operation .)
    EQUALS          reduce using rule 77 (stream_operation -> binary_stream_operation .)
    GT              reduce using rule 77 (stream_operation -> binary_stream_operation .)
    LT              reduce using rule 77 (stream_operation -> binary_stream_operation .)
    GE              reduce using rule 77 (stream_operation -> binary_stream_operation .)
    LE              reduce using rule 77 (stream_operation -> binary_stream_operation .)
    AND             reduce using rule 77 (stream_operation -> binary_stream_operation .)
    OR              reduce using rule 77 (stream_operation -> binary_stream_operation .)
    RPAREN          reduce using rule 77 (stream_operation -> binary_stream_operation .)
    COMMA           reduce using rule 77 (stream_operation -> binary_stream_operation .)


state 50

    (78) stream_operation -> special_stream_operation .

    SEMICOLON       reduce using rule 78 (stream_operation -> special_stream_operation .)
    CALL            reduce using rule 78 (stream_operation -> special_stream_operation .)
    PLUS            reduce using rule 78 (stream_operation -> special_stream_operation .)
    MINUS           reduce using rule 78 (stream_operation -> special_stream_operation .)
    MULTIPLY        reduce using rule 78 (stream_operation -> special_stream_operation .)
    DIVIDE          reduce using rule 78 (stream_operation -> special_stream_operation .)
    EQUALS          reduce using rule 78 (stream_operation -> special_stream_operation .)
    GT              reduce using rule 78 (stream_operation -> special_stream_operation .)
    LT              reduce using rule 78 (stream_operation -> special_stream_operation .)
    GE              reduce using rule 78 (stream_operation -> special_stream_operation .)
    LE              reduce using rule 78 (stream_operation -> special_stream_operation .)
    AND             reduce using rule 78 (stream_operation -> special_stream_operation .)
    OR              reduce using rule 78 (stream_operation -> special_stream_operation .)
    RPAREN          reduce using rule 78 (stream_operation -> special_stream_operation .)
    COMMA           reduce using rule 78 (stream_operation -> special_stream_operation .)


state 51

    (71) unary_logic_operation -> NOT . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 101
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 52

    (8) statement_list -> statement_list statement .

    VAR             reduce using rule 8 (statement_list -> statement_list statement .)
    CONST           reduce using rule 8 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 8 (statement_list -> statement_list statement .)
    IDENTIFIER      reduce using rule 8 (statement_list -> statement_list statement .)
    FN              reduce using rule 8 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 8 (statement_list -> statement_list statement .)
    IF              reduce using rule 8 (statement_list -> statement_list statement .)
    FOR             reduce using rule 8 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 8 (statement_list -> statement_list statement .)
    INT             reduce using rule 8 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 8 (statement_list -> statement_list statement .)
    STRING          reduce using rule 8 (statement_list -> statement_list statement .)
    TRUE            reduce using rule 8 (statement_list -> statement_list statement .)
    FALSE           reduce using rule 8 (statement_list -> statement_list statement .)
    SINT            reduce using rule 8 (statement_list -> statement_list statement .)
    SFLOAT          reduce using rule 8 (statement_list -> statement_list statement .)
    SSTRING         reduce using rule 8 (statement_list -> statement_list statement .)
    SBOOL           reduce using rule 8 (statement_list -> statement_list statement .)
    SSTREAM         reduce using rule 8 (statement_list -> statement_list statement .)
    SEVENT          reduce using rule 8 (statement_list -> statement_list statement .)
    MINUS           reduce using rule 8 (statement_list -> statement_list statement .)
    PLUS            reduce using rule 8 (statement_list -> statement_list statement .)
    NOT             reduce using rule 8 (statement_list -> statement_list statement .)
    $end            reduce using rule 8 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 8 (statement_list -> statement_list statement .)


state 53

    (3) statement -> expression SEMICOLON .

    VAR             reduce using rule 3 (statement -> expression SEMICOLON .)
    CONST           reduce using rule 3 (statement -> expression SEMICOLON .)
    RETURN          reduce using rule 3 (statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 3 (statement -> expression SEMICOLON .)
    FN              reduce using rule 3 (statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 3 (statement -> expression SEMICOLON .)
    IF              reduce using rule 3 (statement -> expression SEMICOLON .)
    FOR             reduce using rule 3 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 3 (statement -> expression SEMICOLON .)
    INT             reduce using rule 3 (statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 3 (statement -> expression SEMICOLON .)
    STRING          reduce using rule 3 (statement -> expression SEMICOLON .)
    TRUE            reduce using rule 3 (statement -> expression SEMICOLON .)
    FALSE           reduce using rule 3 (statement -> expression SEMICOLON .)
    SINT            reduce using rule 3 (statement -> expression SEMICOLON .)
    SFLOAT          reduce using rule 3 (statement -> expression SEMICOLON .)
    SSTRING         reduce using rule 3 (statement -> expression SEMICOLON .)
    SBOOL           reduce using rule 3 (statement -> expression SEMICOLON .)
    SSTREAM         reduce using rule 3 (statement -> expression SEMICOLON .)
    SEVENT          reduce using rule 3 (statement -> expression SEMICOLON .)
    MINUS           reduce using rule 3 (statement -> expression SEMICOLON .)
    PLUS            reduce using rule 3 (statement -> expression SEMICOLON .)
    NOT             reduce using rule 3 (statement -> expression SEMICOLON .)
    $end            reduce using rule 3 (statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 3 (statement -> expression SEMICOLON .)


state 54

    (51) binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .

    SEMICOLON       reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    CALL            reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    PLUS            reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    MINUS           reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    MULTIPLY        reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    DIVIDE          reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    EQUALS          reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    GT              reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    LT              reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    GE              reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    LE              reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    AND             reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    OR              reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    RPAREN          reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)
    COMMA           reduce using rule 51 (binary_arithmetic_operation -> expression binary_arithmetic_operation_rest .)


state 55

    (75) object_call_expression -> expression CALL . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 102
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 56

    (55) binary_logic_operation -> expression binary_logic_operation_rest .

    SEMICOLON       reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    CALL            reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    PLUS            reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    MINUS           reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    MULTIPLY        reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    DIVIDE          reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    EQUALS          reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    GT              reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    LT              reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    GE              reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    LE              reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    AND             reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    OR              reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    RPAREN          reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)
    COMMA           reduce using rule 55 (binary_logic_operation -> expression binary_logic_operation_rest .)


state 57

    (47) binary_arithmetic_operation_rest -> PLUS . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 103
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 58

    (48) binary_arithmetic_operation_rest -> MINUS . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 104
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 59

    (49) binary_arithmetic_operation_rest -> MULTIPLY . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 105
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 60

    (50) binary_arithmetic_operation_rest -> DIVIDE . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 106
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 61

    (57) binary_logic_operation_rest -> EQUALS . ptype
    (64) binary_logic_operation_rest -> EQUALS . expression
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    ptype                          shift and go to state 107
    expression                     shift and go to state 108
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 62

    (58) binary_logic_operation_rest -> GT . ptype
    (65) binary_logic_operation_rest -> GT . expression
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    ptype                          shift and go to state 109
    expression                     shift and go to state 110
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 63

    (59) binary_logic_operation_rest -> LT . ptype
    (66) binary_logic_operation_rest -> LT . expression
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    ptype                          shift and go to state 111
    expression                     shift and go to state 112
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 64

    (60) binary_logic_operation_rest -> GE . ptype
    (67) binary_logic_operation_rest -> GE . expression
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    ptype                          shift and go to state 113
    expression                     shift and go to state 114
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 65

    (61) binary_logic_operation_rest -> LE . ptype
    (68) binary_logic_operation_rest -> LE . expression
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    ptype                          shift and go to state 115
    expression                     shift and go to state 116
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 66

    (62) binary_logic_operation_rest -> AND . ptype
    (69) binary_logic_operation_rest -> AND . expression
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    ptype                          shift and go to state 117
    expression                     shift and go to state 118
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 67

    (63) binary_logic_operation_rest -> OR . ptype
    (70) binary_logic_operation_rest -> OR . expression
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    ptype                          shift and go to state 119
    expression                     shift and go to state 120
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 68

    (4) statement -> return_statement SEMICOLON .

    VAR             reduce using rule 4 (statement -> return_statement SEMICOLON .)
    CONST           reduce using rule 4 (statement -> return_statement SEMICOLON .)
    RETURN          reduce using rule 4 (statement -> return_statement SEMICOLON .)
    IDENTIFIER      reduce using rule 4 (statement -> return_statement SEMICOLON .)
    FN              reduce using rule 4 (statement -> return_statement SEMICOLON .)
    LPAREN          reduce using rule 4 (statement -> return_statement SEMICOLON .)
    IF              reduce using rule 4 (statement -> return_statement SEMICOLON .)
    FOR             reduce using rule 4 (statement -> return_statement SEMICOLON .)
    WHILE           reduce using rule 4 (statement -> return_statement SEMICOLON .)
    INT             reduce using rule 4 (statement -> return_statement SEMICOLON .)
    FLOAT           reduce using rule 4 (statement -> return_statement SEMICOLON .)
    STRING          reduce using rule 4 (statement -> return_statement SEMICOLON .)
    TRUE            reduce using rule 4 (statement -> return_statement SEMICOLON .)
    FALSE           reduce using rule 4 (statement -> return_statement SEMICOLON .)
    SINT            reduce using rule 4 (statement -> return_statement SEMICOLON .)
    SFLOAT          reduce using rule 4 (statement -> return_statement SEMICOLON .)
    SSTRING         reduce using rule 4 (statement -> return_statement SEMICOLON .)
    SBOOL           reduce using rule 4 (statement -> return_statement SEMICOLON .)
    SSTREAM         reduce using rule 4 (statement -> return_statement SEMICOLON .)
    SEVENT          reduce using rule 4 (statement -> return_statement SEMICOLON .)
    MINUS           reduce using rule 4 (statement -> return_statement SEMICOLON .)
    PLUS            reduce using rule 4 (statement -> return_statement SEMICOLON .)
    NOT             reduce using rule 4 (statement -> return_statement SEMICOLON .)
    $end            reduce using rule 4 (statement -> return_statement SEMICOLON .)
    RBRACE          reduce using rule 4 (statement -> return_statement SEMICOLON .)


state 69

    (6) statement -> assignment SEMICOLON .

    VAR             reduce using rule 6 (statement -> assignment SEMICOLON .)
    CONST           reduce using rule 6 (statement -> assignment SEMICOLON .)
    RETURN          reduce using rule 6 (statement -> assignment SEMICOLON .)
    IDENTIFIER      reduce using rule 6 (statement -> assignment SEMICOLON .)
    FN              reduce using rule 6 (statement -> assignment SEMICOLON .)
    LPAREN          reduce using rule 6 (statement -> assignment SEMICOLON .)
    IF              reduce using rule 6 (statement -> assignment SEMICOLON .)
    FOR             reduce using rule 6 (statement -> assignment SEMICOLON .)
    WHILE           reduce using rule 6 (statement -> assignment SEMICOLON .)
    INT             reduce using rule 6 (statement -> assignment SEMICOLON .)
    FLOAT           reduce using rule 6 (statement -> assignment SEMICOLON .)
    STRING          reduce using rule 6 (statement -> assignment SEMICOLON .)
    TRUE            reduce using rule 6 (statement -> assignment SEMICOLON .)
    FALSE           reduce using rule 6 (statement -> assignment SEMICOLON .)
    SINT            reduce using rule 6 (statement -> assignment SEMICOLON .)
    SFLOAT          reduce using rule 6 (statement -> assignment SEMICOLON .)
    SSTRING         reduce using rule 6 (statement -> assignment SEMICOLON .)
    SBOOL           reduce using rule 6 (statement -> assignment SEMICOLON .)
    SSTREAM         reduce using rule 6 (statement -> assignment SEMICOLON .)
    SEVENT          reduce using rule 6 (statement -> assignment SEMICOLON .)
    MINUS           reduce using rule 6 (statement -> assignment SEMICOLON .)
    PLUS            reduce using rule 6 (statement -> assignment SEMICOLON .)
    NOT             reduce using rule 6 (statement -> assignment SEMICOLON .)
    $end            reduce using rule 6 (statement -> assignment SEMICOLON .)
    RBRACE          reduce using rule 6 (statement -> assignment SEMICOLON .)


state 70

    (28) declaration -> VAR declaration_base . SEMICOLON

    SEMICOLON       shift and go to state 121


state 71

    (31) declaration_base -> IDENTIFIER .
    (32) declaration_base -> IDENTIFIER . ASSIGN expression
    (33) declaration_base -> IDENTIFIER . typehint
    (34) declaration_base -> IDENTIFIER . typehint ASSIGN expression
    (35) typehint -> . TYPEHINTCOLON type

    SEMICOLON       reduce using rule 31 (declaration_base -> IDENTIFIER .)
    ASSIGN          shift and go to state 122
    TYPEHINTCOLON   shift and go to state 124

    typehint                       shift and go to state 123

state 72

    (29) declaration -> CONST declaration_base . SEMICOLON

    SEMICOLON       shift and go to state 125


state 73

    (16) return_statement -> RETURN expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    SEMICOLON       reduce using rule 16 (return_statement -> RETURN expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 74

    (89) simple_expression -> IDENTIFIER .
    (9) function_call -> IDENTIFIER . LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> IDENTIFIER . TO_STREAM
    (80) binary_stream_operation -> IDENTIFIER . CHAIN IDENTIFIER
    (81) binary_stream_operation -> IDENTIFIER . STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> IDENTIFIER . STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> IDENTIFIER . FEEDBACK IDENTIFIER
    (84) special_stream_operation -> IDENTIFIER . FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> IDENTIFIER . MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> IDENTIFIER . REDUCE LPAREN logic_expression RPAREN

    CALL            reduce using rule 89 (simple_expression -> IDENTIFIER .)
    PLUS            reduce using rule 89 (simple_expression -> IDENTIFIER .)
    MINUS           reduce using rule 89 (simple_expression -> IDENTIFIER .)
    MULTIPLY        reduce using rule 89 (simple_expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 89 (simple_expression -> IDENTIFIER .)
    EQUALS          reduce using rule 89 (simple_expression -> IDENTIFIER .)
    GT              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    LT              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    GE              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    LE              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    AND             reduce using rule 89 (simple_expression -> IDENTIFIER .)
    OR              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 89 (simple_expression -> IDENTIFIER .)
    RPAREN          reduce using rule 89 (simple_expression -> IDENTIFIER .)
    COMMA           reduce using rule 89 (simple_expression -> IDENTIFIER .)
    LPAREN          shift and go to state 77
    TO_STREAM       shift and go to state 78
    CHAIN           shift and go to state 79
    STREAMSPLIT     shift and go to state 80
    STREAMMERGE     shift and go to state 81
    FEEDBACK        shift and go to state 82
    FILTEROP        shift and go to state 83
    MAP             shift and go to state 84
    REDUCE          shift and go to state 85


state 75

    (18) lambda_function -> FN . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> FN . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement

    LPAREN          shift and go to state 87


state 76

    (106) assignment -> IDENTIFIER ASSIGN . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 126
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 77

    (9) function_call -> IDENTIFIER LPAREN . opt_arg_list RPAREN
    (10) opt_arg_list -> . arg_list
    (11) opt_arg_list -> . empty
    (12) arg_list -> . expression
    (13) arg_list -> . arg_list COMMA expression
    (107) empty -> .
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    RPAREN          reduce using rule 107 (empty -> .)
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    opt_arg_list                   shift and go to state 127
    arg_list                       shift and go to state 128
    empty                          shift and go to state 129
    expression                     shift and go to state 130
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 78

    (79) unary_stream_operation -> IDENTIFIER TO_STREAM .

    SEMICOLON       reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    CALL            reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    PLUS            reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    MINUS           reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    MULTIPLY        reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    DIVIDE          reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    EQUALS          reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    GT              reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    LT              reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    GE              reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    LE              reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    AND             reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    OR              reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    RPAREN          reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)
    COMMA           reduce using rule 79 (unary_stream_operation -> IDENTIFIER TO_STREAM .)


state 79

    (80) binary_stream_operation -> IDENTIFIER CHAIN . IDENTIFIER

    IDENTIFIER      shift and go to state 131


state 80

    (81) binary_stream_operation -> IDENTIFIER STREAMSPLIT . IDENTIFIER

    IDENTIFIER      shift and go to state 132


state 81

    (82) binary_stream_operation -> IDENTIFIER STREAMMERGE . IDENTIFIER

    IDENTIFIER      shift and go to state 133


state 82

    (83) binary_stream_operation -> IDENTIFIER FEEDBACK . IDENTIFIER

    IDENTIFIER      shift and go to state 134


state 83

    (84) special_stream_operation -> IDENTIFIER FILTEROP . LPAREN logic_expression RPAREN

    LPAREN          shift and go to state 135


state 84

    (85) special_stream_operation -> IDENTIFIER MAP . LPAREN logic_expression RPAREN

    LPAREN          shift and go to state 136


state 85

    (86) special_stream_operation -> IDENTIFIER REDUCE . LPAREN logic_expression RPAREN

    LPAREN          shift and go to state 137


state 86

    (14) function_definition -> FN IDENTIFIER . LPAREN opt_param_list RPAREN block_statement
    (15) function_definition -> FN IDENTIFIER . LPAREN opt_param_list RPAREN typehint block_statement

    LPAREN          shift and go to state 138


state 87

    (18) lambda_function -> FN LPAREN . opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> FN LPAREN . opt_param_list RPAREN typehint LAMBDA block_statement
    (22) opt_param_list -> . param_list
    (23) opt_param_list -> . empty
    (24) param_list -> . param
    (25) param_list -> . param_list COMMA param
    (107) empty -> .
    (26) param -> . IDENTIFIER
    (27) param -> . IDENTIFIER typehint

    RPAREN          reduce using rule 107 (empty -> .)
    IDENTIFIER      shift and go to state 140

    opt_param_list                 shift and go to state 139
    param_list                     shift and go to state 90
    empty                          shift and go to state 91
    param                          shift and go to state 93

state 88

    (90) simple_expression -> LPAREN expression . RPAREN
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    RPAREN          shift and go to state 141
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 89

    (20) lambda_function -> LPAREN opt_param_list . RPAREN LAMBDA block_statement
    (21) lambda_function -> LPAREN opt_param_list . RPAREN typehint LAMBDA block_statement

    RPAREN          shift and go to state 142


state 90

    (22) opt_param_list -> param_list .
    (25) param_list -> param_list . COMMA param

    RPAREN          reduce using rule 22 (opt_param_list -> param_list .)
    COMMA           shift and go to state 143


state 91

    (23) opt_param_list -> empty .

    RPAREN          reduce using rule 23 (opt_param_list -> empty .)


state 92

    (89) simple_expression -> IDENTIFIER .
    (26) param -> IDENTIFIER .
    (27) param -> IDENTIFIER . typehint
    (9) function_call -> IDENTIFIER . LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> IDENTIFIER . TO_STREAM
    (80) binary_stream_operation -> IDENTIFIER . CHAIN IDENTIFIER
    (81) binary_stream_operation -> IDENTIFIER . STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> IDENTIFIER . STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> IDENTIFIER . FEEDBACK IDENTIFIER
    (84) special_stream_operation -> IDENTIFIER . FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> IDENTIFIER . MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> IDENTIFIER . REDUCE LPAREN logic_expression RPAREN
    (35) typehint -> . TYPEHINTCOLON type

  ! reduce/reduce conflict for RPAREN resolved using rule 26 (param -> IDENTIFIER .)
    CALL            reduce using rule 89 (simple_expression -> IDENTIFIER .)
    PLUS            reduce using rule 89 (simple_expression -> IDENTIFIER .)
    MINUS           reduce using rule 89 (simple_expression -> IDENTIFIER .)
    MULTIPLY        reduce using rule 89 (simple_expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 89 (simple_expression -> IDENTIFIER .)
    EQUALS          reduce using rule 89 (simple_expression -> IDENTIFIER .)
    GT              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    LT              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    GE              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    LE              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    AND             reduce using rule 89 (simple_expression -> IDENTIFIER .)
    OR              reduce using rule 89 (simple_expression -> IDENTIFIER .)
    COMMA           reduce using rule 26 (param -> IDENTIFIER .)
    RPAREN          reduce using rule 26 (param -> IDENTIFIER .)
    LPAREN          shift and go to state 77
    TO_STREAM       shift and go to state 78
    CHAIN           shift and go to state 79
    STREAMSPLIT     shift and go to state 80
    STREAMMERGE     shift and go to state 81
    FEEDBACK        shift and go to state 82
    FILTEROP        shift and go to state 83
    MAP             shift and go to state 84
    REDUCE          shift and go to state 85
    TYPEHINTCOLON   shift and go to state 124

  ! RPAREN          [ reduce using rule 89 (simple_expression -> IDENTIFIER .) ]

    typehint                       shift and go to state 144

state 93

    (24) param_list -> param .

    COMMA           reduce using rule 24 (param_list -> param .)
    RPAREN          reduce using rule 24 (param_list -> param .)


state 94

    (52) binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .

    SEMICOLON       reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    CALL            reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    PLUS            reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    MINUS           reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    MULTIPLY        reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    DIVIDE          reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    EQUALS          reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    GT              reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    LT              reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    GE              reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    LE              reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    AND             reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    OR              reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    RPAREN          reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)
    COMMA           reduce using rule 52 (binary_arithmetic_operation -> ptype binary_arithmetic_operation_rest .)


state 95

    (56) binary_logic_operation -> ptype binary_logic_operation_rest .

    SEMICOLON       reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    CALL            reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    PLUS            reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    MINUS           reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    MULTIPLY        reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    DIVIDE          reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    EQUALS          reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    GT              reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    LT              reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    GE              reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    LE              reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    AND             reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    OR              reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    RPAREN          reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)
    COMMA           reduce using rule 56 (binary_logic_operation -> ptype binary_logic_operation_rest .)


state 96

    (102) conditional -> IF LPAREN . expression RPAREN block_statement ELSE block_statement
    (103) conditional -> IF LPAREN . expression RPAREN block_statement
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 145
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 97

    (104) loop -> FOR LPAREN . declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement
    (28) declaration -> . VAR declaration_base SEMICOLON
    (29) declaration -> . CONST declaration_base SEMICOLON
    (30) declaration -> . function_definition
    (14) function_definition -> . FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement
    (15) function_definition -> . FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement

    VAR             shift and go to state 9
    CONST           shift and go to state 10
    FN              shift and go to state 147

    declaration                    shift and go to state 146
    function_definition            shift and go to state 11

state 98

    (105) loop -> WHILE LPAREN . expression RPAREN block_statement
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 148
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 99

    (53) unary_arithmetic_operation -> MINUS expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .)
    RPAREN          reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .)
    COMMA           reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! PLUS            [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! MULTIPLY        [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! EQUALS          [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! GT              [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! LT              [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! GE              [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! LE              [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! AND             [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]
  ! OR              [ reduce using rule 53 (unary_arithmetic_operation -> MINUS expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 100

    (54) unary_arithmetic_operation -> PLUS expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .)
    RPAREN          reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .)
    COMMA           reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! PLUS            [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! MINUS           [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! MULTIPLY        [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! EQUALS          [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! GT              [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! LT              [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! GE              [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! LE              [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! AND             [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]
  ! OR              [ reduce using rule 54 (unary_arithmetic_operation -> PLUS expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 101

    (71) unary_logic_operation -> NOT expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 71 (unary_logic_operation -> NOT expression .)
    RPAREN          reduce using rule 71 (unary_logic_operation -> NOT expression .)
    COMMA           reduce using rule 71 (unary_logic_operation -> NOT expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! PLUS            [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! MINUS           [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! MULTIPLY        [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! DIVIDE          [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! EQUALS          [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! GT              [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! LT              [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! GE              [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! LE              [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! AND             [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]
  ! OR              [ reduce using rule 71 (unary_logic_operation -> NOT expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 102

    (75) object_call_expression -> expression CALL expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 75 (object_call_expression -> expression CALL expression .)
    RPAREN          reduce using rule 75 (object_call_expression -> expression CALL expression .)
    COMMA           reduce using rule 75 (object_call_expression -> expression CALL expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! PLUS            [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! MINUS           [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! MULTIPLY        [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! DIVIDE          [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! EQUALS          [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! GT              [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! LT              [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! GE              [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! LE              [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! AND             [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]
  ! OR              [ reduce using rule 75 (object_call_expression -> expression CALL expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 103

    (47) binary_arithmetic_operation_rest -> PLUS expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .)
    RPAREN          reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .)
    COMMA           reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! PLUS            [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! MINUS           [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! MULTIPLY        [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! EQUALS          [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! GT              [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! LT              [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! GE              [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! LE              [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! AND             [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]
  ! OR              [ reduce using rule 47 (binary_arithmetic_operation_rest -> PLUS expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 104

    (48) binary_arithmetic_operation_rest -> MINUS expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .)
    RPAREN          reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .)
    COMMA           reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! PLUS            [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! MULTIPLY        [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! EQUALS          [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! GT              [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! LT              [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! GE              [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! LE              [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! AND             [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]
  ! OR              [ reduce using rule 48 (binary_arithmetic_operation_rest -> MINUS expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 105

    (49) binary_arithmetic_operation_rest -> MULTIPLY expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .)
    RPAREN          reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .)
    COMMA           reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! PLUS            [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! MINUS           [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! MULTIPLY        [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! DIVIDE          [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! EQUALS          [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! GT              [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! LT              [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! GE              [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! LE              [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! AND             [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]
  ! OR              [ reduce using rule 49 (binary_arithmetic_operation_rest -> MULTIPLY expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 106

    (50) binary_arithmetic_operation_rest -> DIVIDE expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .)
    RPAREN          reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .)
    COMMA           reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! PLUS            [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! MULTIPLY        [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! EQUALS          [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! GT              [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! LT              [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! GE              [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! LE              [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! AND             [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]
  ! OR              [ reduce using rule 50 (binary_arithmetic_operation_rest -> DIVIDE expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 107

    (57) binary_logic_operation_rest -> EQUALS ptype .
    (87) simple_expression -> ptype .
    (52) binary_arithmetic_operation -> ptype . binary_arithmetic_operation_rest
    (56) binary_logic_operation -> ptype . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! reduce/reduce conflict for SEMICOLON resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for CALL resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for PLUS resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for MINUS resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for MULTIPLY resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for EQUALS resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for GT resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for LT resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for GE resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for LE resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for AND resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for OR resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for RPAREN resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! reduce/reduce conflict for COMMA resolved using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
    CALL            reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
    RPAREN          reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
    COMMA           reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! MINUS           [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! MULTIPLY        [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! DIVIDE          [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! EQUALS          [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! GT              [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! LT              [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! GE              [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! LE              [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! AND             [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! OR              [ reduce using rule 57 (binary_logic_operation_rest -> EQUALS ptype .) ]
  ! SEMICOLON       [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! CALL            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! PLUS            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MINUS           [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MULTIPLY        [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! DIVIDE          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! EQUALS          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! AND             [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! OR              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! RPAREN          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! COMMA           [ reduce using rule 87 (simple_expression -> ptype .) ]

    binary_arithmetic_operation_rest shift and go to state 94
    binary_logic_operation_rest    shift and go to state 95

state 108

    (64) binary_logic_operation_rest -> EQUALS expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .)
    RPAREN          reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .)
    COMMA           reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! PLUS            [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! MINUS           [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! MULTIPLY        [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! DIVIDE          [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! EQUALS          [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! GT              [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! LT              [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! GE              [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! LE              [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! AND             [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]
  ! OR              [ reduce using rule 64 (binary_logic_operation_rest -> EQUALS expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 109

    (58) binary_logic_operation_rest -> GT ptype .
    (87) simple_expression -> ptype .
    (52) binary_arithmetic_operation -> ptype . binary_arithmetic_operation_rest
    (56) binary_logic_operation -> ptype . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! reduce/reduce conflict for SEMICOLON resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for CALL resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for PLUS resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for MINUS resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for MULTIPLY resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for EQUALS resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for GT resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for LT resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for GE resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for LE resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for AND resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for OR resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for RPAREN resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! reduce/reduce conflict for COMMA resolved using rule 58 (binary_logic_operation_rest -> GT ptype .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 58 (binary_logic_operation_rest -> GT ptype .)
    CALL            reduce using rule 58 (binary_logic_operation_rest -> GT ptype .)
    RPAREN          reduce using rule 58 (binary_logic_operation_rest -> GT ptype .)
    COMMA           reduce using rule 58 (binary_logic_operation_rest -> GT ptype .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! MINUS           [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! MULTIPLY        [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! DIVIDE          [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! EQUALS          [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! GT              [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! LT              [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! GE              [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! LE              [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! AND             [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! OR              [ reduce using rule 58 (binary_logic_operation_rest -> GT ptype .) ]
  ! SEMICOLON       [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! CALL            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! PLUS            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MINUS           [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MULTIPLY        [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! DIVIDE          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! EQUALS          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! AND             [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! OR              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! RPAREN          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! COMMA           [ reduce using rule 87 (simple_expression -> ptype .) ]

    binary_arithmetic_operation_rest shift and go to state 94
    binary_logic_operation_rest    shift and go to state 95

state 110

    (65) binary_logic_operation_rest -> GT expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 65 (binary_logic_operation_rest -> GT expression .)
    RPAREN          reduce using rule 65 (binary_logic_operation_rest -> GT expression .)
    COMMA           reduce using rule 65 (binary_logic_operation_rest -> GT expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! PLUS            [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! MINUS           [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! MULTIPLY        [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! DIVIDE          [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! EQUALS          [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! GT              [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! LT              [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! GE              [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! LE              [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! AND             [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]
  ! OR              [ reduce using rule 65 (binary_logic_operation_rest -> GT expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 111

    (59) binary_logic_operation_rest -> LT ptype .
    (87) simple_expression -> ptype .
    (52) binary_arithmetic_operation -> ptype . binary_arithmetic_operation_rest
    (56) binary_logic_operation -> ptype . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! reduce/reduce conflict for SEMICOLON resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for CALL resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for PLUS resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for MINUS resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for MULTIPLY resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for EQUALS resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for GT resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for LT resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for GE resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for LE resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for AND resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for OR resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for RPAREN resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! reduce/reduce conflict for COMMA resolved using rule 59 (binary_logic_operation_rest -> LT ptype .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 59 (binary_logic_operation_rest -> LT ptype .)
    CALL            reduce using rule 59 (binary_logic_operation_rest -> LT ptype .)
    RPAREN          reduce using rule 59 (binary_logic_operation_rest -> LT ptype .)
    COMMA           reduce using rule 59 (binary_logic_operation_rest -> LT ptype .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! MINUS           [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! MULTIPLY        [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! DIVIDE          [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! EQUALS          [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! GT              [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! LT              [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! GE              [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! LE              [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! AND             [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! OR              [ reduce using rule 59 (binary_logic_operation_rest -> LT ptype .) ]
  ! SEMICOLON       [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! CALL            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! PLUS            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MINUS           [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MULTIPLY        [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! DIVIDE          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! EQUALS          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! AND             [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! OR              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! RPAREN          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! COMMA           [ reduce using rule 87 (simple_expression -> ptype .) ]

    binary_arithmetic_operation_rest shift and go to state 94
    binary_logic_operation_rest    shift and go to state 95

state 112

    (66) binary_logic_operation_rest -> LT expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 66 (binary_logic_operation_rest -> LT expression .)
    RPAREN          reduce using rule 66 (binary_logic_operation_rest -> LT expression .)
    COMMA           reduce using rule 66 (binary_logic_operation_rest -> LT expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! PLUS            [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! MINUS           [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! MULTIPLY        [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! DIVIDE          [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! EQUALS          [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! GT              [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! LT              [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! GE              [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! LE              [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! AND             [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]
  ! OR              [ reduce using rule 66 (binary_logic_operation_rest -> LT expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 113

    (60) binary_logic_operation_rest -> GE ptype .
    (87) simple_expression -> ptype .
    (52) binary_arithmetic_operation -> ptype . binary_arithmetic_operation_rest
    (56) binary_logic_operation -> ptype . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! reduce/reduce conflict for SEMICOLON resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for CALL resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for PLUS resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for MINUS resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for MULTIPLY resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for EQUALS resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for GT resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for LT resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for GE resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for LE resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for AND resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for OR resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for RPAREN resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! reduce/reduce conflict for COMMA resolved using rule 60 (binary_logic_operation_rest -> GE ptype .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 60 (binary_logic_operation_rest -> GE ptype .)
    CALL            reduce using rule 60 (binary_logic_operation_rest -> GE ptype .)
    RPAREN          reduce using rule 60 (binary_logic_operation_rest -> GE ptype .)
    COMMA           reduce using rule 60 (binary_logic_operation_rest -> GE ptype .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! MINUS           [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! MULTIPLY        [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! DIVIDE          [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! EQUALS          [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! GT              [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! LT              [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! GE              [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! LE              [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! AND             [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! OR              [ reduce using rule 60 (binary_logic_operation_rest -> GE ptype .) ]
  ! SEMICOLON       [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! CALL            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! PLUS            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MINUS           [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MULTIPLY        [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! DIVIDE          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! EQUALS          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! AND             [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! OR              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! RPAREN          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! COMMA           [ reduce using rule 87 (simple_expression -> ptype .) ]

    binary_arithmetic_operation_rest shift and go to state 94
    binary_logic_operation_rest    shift and go to state 95

state 114

    (67) binary_logic_operation_rest -> GE expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 67 (binary_logic_operation_rest -> GE expression .)
    RPAREN          reduce using rule 67 (binary_logic_operation_rest -> GE expression .)
    COMMA           reduce using rule 67 (binary_logic_operation_rest -> GE expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! PLUS            [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! MINUS           [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! MULTIPLY        [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! DIVIDE          [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! EQUALS          [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! GT              [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! LT              [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! GE              [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! LE              [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! AND             [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]
  ! OR              [ reduce using rule 67 (binary_logic_operation_rest -> GE expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 115

    (61) binary_logic_operation_rest -> LE ptype .
    (87) simple_expression -> ptype .
    (52) binary_arithmetic_operation -> ptype . binary_arithmetic_operation_rest
    (56) binary_logic_operation -> ptype . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! reduce/reduce conflict for SEMICOLON resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for CALL resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for PLUS resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for MINUS resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for MULTIPLY resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for EQUALS resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for GT resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for LT resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for GE resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for LE resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for AND resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for OR resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for RPAREN resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! reduce/reduce conflict for COMMA resolved using rule 61 (binary_logic_operation_rest -> LE ptype .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 61 (binary_logic_operation_rest -> LE ptype .)
    CALL            reduce using rule 61 (binary_logic_operation_rest -> LE ptype .)
    RPAREN          reduce using rule 61 (binary_logic_operation_rest -> LE ptype .)
    COMMA           reduce using rule 61 (binary_logic_operation_rest -> LE ptype .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! MINUS           [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! MULTIPLY        [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! DIVIDE          [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! EQUALS          [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! GT              [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! LT              [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! GE              [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! LE              [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! AND             [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! OR              [ reduce using rule 61 (binary_logic_operation_rest -> LE ptype .) ]
  ! SEMICOLON       [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! CALL            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! PLUS            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MINUS           [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MULTIPLY        [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! DIVIDE          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! EQUALS          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! AND             [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! OR              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! RPAREN          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! COMMA           [ reduce using rule 87 (simple_expression -> ptype .) ]

    binary_arithmetic_operation_rest shift and go to state 94
    binary_logic_operation_rest    shift and go to state 95

state 116

    (68) binary_logic_operation_rest -> LE expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 68 (binary_logic_operation_rest -> LE expression .)
    RPAREN          reduce using rule 68 (binary_logic_operation_rest -> LE expression .)
    COMMA           reduce using rule 68 (binary_logic_operation_rest -> LE expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! PLUS            [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! MINUS           [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! MULTIPLY        [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! DIVIDE          [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! EQUALS          [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! GT              [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! LT              [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! GE              [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! LE              [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! AND             [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]
  ! OR              [ reduce using rule 68 (binary_logic_operation_rest -> LE expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 117

    (62) binary_logic_operation_rest -> AND ptype .
    (87) simple_expression -> ptype .
    (52) binary_arithmetic_operation -> ptype . binary_arithmetic_operation_rest
    (56) binary_logic_operation -> ptype . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! reduce/reduce conflict for SEMICOLON resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for CALL resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for PLUS resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for MINUS resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for MULTIPLY resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for EQUALS resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for GT resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for LT resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for GE resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for LE resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for AND resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for OR resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for RPAREN resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! reduce/reduce conflict for COMMA resolved using rule 62 (binary_logic_operation_rest -> AND ptype .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 62 (binary_logic_operation_rest -> AND ptype .)
    CALL            reduce using rule 62 (binary_logic_operation_rest -> AND ptype .)
    RPAREN          reduce using rule 62 (binary_logic_operation_rest -> AND ptype .)
    COMMA           reduce using rule 62 (binary_logic_operation_rest -> AND ptype .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! MINUS           [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! MULTIPLY        [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! DIVIDE          [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! EQUALS          [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! GT              [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! LT              [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! GE              [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! LE              [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! AND             [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! OR              [ reduce using rule 62 (binary_logic_operation_rest -> AND ptype .) ]
  ! SEMICOLON       [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! CALL            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! PLUS            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MINUS           [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MULTIPLY        [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! DIVIDE          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! EQUALS          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! AND             [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! OR              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! RPAREN          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! COMMA           [ reduce using rule 87 (simple_expression -> ptype .) ]

    binary_arithmetic_operation_rest shift and go to state 94
    binary_logic_operation_rest    shift and go to state 95

state 118

    (69) binary_logic_operation_rest -> AND expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 69 (binary_logic_operation_rest -> AND expression .)
    RPAREN          reduce using rule 69 (binary_logic_operation_rest -> AND expression .)
    COMMA           reduce using rule 69 (binary_logic_operation_rest -> AND expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! PLUS            [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! MINUS           [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! MULTIPLY        [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! DIVIDE          [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! EQUALS          [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! GT              [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! LT              [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! GE              [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! LE              [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! AND             [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]
  ! OR              [ reduce using rule 69 (binary_logic_operation_rest -> AND expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 119

    (63) binary_logic_operation_rest -> OR ptype .
    (87) simple_expression -> ptype .
    (52) binary_arithmetic_operation -> ptype . binary_arithmetic_operation_rest
    (56) binary_logic_operation -> ptype . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! reduce/reduce conflict for SEMICOLON resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for CALL resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for PLUS resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for MINUS resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for MULTIPLY resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for EQUALS resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for GT resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for LT resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for GE resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for LE resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for AND resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for OR resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for RPAREN resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! reduce/reduce conflict for COMMA resolved using rule 63 (binary_logic_operation_rest -> OR ptype .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 63 (binary_logic_operation_rest -> OR ptype .)
    CALL            reduce using rule 63 (binary_logic_operation_rest -> OR ptype .)
    RPAREN          reduce using rule 63 (binary_logic_operation_rest -> OR ptype .)
    COMMA           reduce using rule 63 (binary_logic_operation_rest -> OR ptype .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! MINUS           [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! MULTIPLY        [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! DIVIDE          [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! EQUALS          [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! GT              [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! LT              [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! GE              [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! LE              [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! AND             [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! OR              [ reduce using rule 63 (binary_logic_operation_rest -> OR ptype .) ]
  ! SEMICOLON       [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! CALL            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! PLUS            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MINUS           [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MULTIPLY        [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! DIVIDE          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! EQUALS          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! AND             [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! OR              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! RPAREN          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! COMMA           [ reduce using rule 87 (simple_expression -> ptype .) ]

    binary_arithmetic_operation_rest shift and go to state 94
    binary_logic_operation_rest    shift and go to state 95

state 120

    (70) binary_logic_operation_rest -> OR expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

  ! shift/reduce conflict for CALL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 70 (binary_logic_operation_rest -> OR expression .)
    RPAREN          reduce using rule 70 (binary_logic_operation_rest -> OR expression .)
    COMMA           reduce using rule 70 (binary_logic_operation_rest -> OR expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! CALL            [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! PLUS            [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! MINUS           [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! MULTIPLY        [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! DIVIDE          [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! EQUALS          [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! GT              [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! LT              [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! GE              [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! LE              [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! AND             [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]
  ! OR              [ reduce using rule 70 (binary_logic_operation_rest -> OR expression .) ]

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 121

    (28) declaration -> VAR declaration_base SEMICOLON .

    VAR             reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    CONST           reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    RETURN          reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    FN              reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    LPAREN          reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    IF              reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    FOR             reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    WHILE           reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    INT             reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    FLOAT           reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    STRING          reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    TRUE            reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    FALSE           reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    SINT            reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    SFLOAT          reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    SSTRING         reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    SBOOL           reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    SSTREAM         reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    SEVENT          reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    MINUS           reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    PLUS            reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    NOT             reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    $end            reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    SEMICOLON       reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)
    RBRACE          reduce using rule 28 (declaration -> VAR declaration_base SEMICOLON .)


state 122

    (32) declaration_base -> IDENTIFIER ASSIGN . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 149
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 123

    (33) declaration_base -> IDENTIFIER typehint .
    (34) declaration_base -> IDENTIFIER typehint . ASSIGN expression

    SEMICOLON       reduce using rule 33 (declaration_base -> IDENTIFIER typehint .)
    ASSIGN          shift and go to state 150


state 124

    (35) typehint -> TYPEHINTCOLON . type
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT

    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42

    type                           shift and go to state 151

state 125

    (29) declaration -> CONST declaration_base SEMICOLON .

    VAR             reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    CONST           reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    RETURN          reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    IDENTIFIER      reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    FN              reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    LPAREN          reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    IF              reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    FOR             reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    WHILE           reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    INT             reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    FLOAT           reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    STRING          reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    TRUE            reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    FALSE           reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    SINT            reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    SFLOAT          reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    SSTRING         reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    SBOOL           reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    SSTREAM         reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    SEVENT          reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    MINUS           reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    PLUS            reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    NOT             reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    $end            reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    SEMICOLON       reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)
    RBRACE          reduce using rule 29 (declaration -> CONST declaration_base SEMICOLON .)


state 126

    (106) assignment -> IDENTIFIER ASSIGN expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    SEMICOLON       reduce using rule 106 (assignment -> IDENTIFIER ASSIGN expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 127

    (9) function_call -> IDENTIFIER LPAREN opt_arg_list . RPAREN

    RPAREN          shift and go to state 152


state 128

    (10) opt_arg_list -> arg_list .
    (13) arg_list -> arg_list . COMMA expression

    RPAREN          reduce using rule 10 (opt_arg_list -> arg_list .)
    COMMA           shift and go to state 153


state 129

    (11) opt_arg_list -> empty .

    RPAREN          reduce using rule 11 (opt_arg_list -> empty .)


state 130

    (12) arg_list -> expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    COMMA           reduce using rule 12 (arg_list -> expression .)
    RPAREN          reduce using rule 12 (arg_list -> expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 131

    (80) binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .

    SEMICOLON       reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    CALL            reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    PLUS            reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    MINUS           reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    MULTIPLY        reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    DIVIDE          reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    EQUALS          reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    GT              reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    LT              reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    GE              reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    LE              reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    AND             reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    OR              reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    RPAREN          reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)
    COMMA           reduce using rule 80 (binary_stream_operation -> IDENTIFIER CHAIN IDENTIFIER .)


state 132

    (81) binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .

    SEMICOLON       reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    CALL            reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    PLUS            reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    MINUS           reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    MULTIPLY        reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    DIVIDE          reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    EQUALS          reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    GT              reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    LT              reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    GE              reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    LE              reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    AND             reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    OR              reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    RPAREN          reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)
    COMMA           reduce using rule 81 (binary_stream_operation -> IDENTIFIER STREAMSPLIT IDENTIFIER .)


state 133

    (82) binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .

    SEMICOLON       reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    CALL            reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    PLUS            reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    MINUS           reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    MULTIPLY        reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    DIVIDE          reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    EQUALS          reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    GT              reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    LT              reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    GE              reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    LE              reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    AND             reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    OR              reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    RPAREN          reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)
    COMMA           reduce using rule 82 (binary_stream_operation -> IDENTIFIER STREAMMERGE IDENTIFIER .)


state 134

    (83) binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .

    SEMICOLON       reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    CALL            reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    PLUS            reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    MINUS           reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    MULTIPLY        reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    DIVIDE          reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    EQUALS          reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    GT              reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    LT              reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    GE              reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    LE              reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    AND             reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    OR              reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    RPAREN          reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)
    COMMA           reduce using rule 83 (binary_stream_operation -> IDENTIFIER FEEDBACK IDENTIFIER .)


state 135

    (84) special_stream_operation -> IDENTIFIER FILTEROP LPAREN . logic_expression RPAREN
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    NOT             shift and go to state 51
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44

    logic_expression               shift and go to state 154
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    expression                     shift and go to state 155
    ptype                          shift and go to state 156
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 136

    (85) special_stream_operation -> IDENTIFIER MAP LPAREN . logic_expression RPAREN
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    NOT             shift and go to state 51
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44

    logic_expression               shift and go to state 157
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    expression                     shift and go to state 155
    ptype                          shift and go to state 156
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 137

    (86) special_stream_operation -> IDENTIFIER REDUCE LPAREN . logic_expression RPAREN
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    NOT             shift and go to state 51
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44

    logic_expression               shift and go to state 158
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    expression                     shift and go to state 155
    ptype                          shift and go to state 156
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 138

    (14) function_definition -> FN IDENTIFIER LPAREN . opt_param_list RPAREN block_statement
    (15) function_definition -> FN IDENTIFIER LPAREN . opt_param_list RPAREN typehint block_statement
    (22) opt_param_list -> . param_list
    (23) opt_param_list -> . empty
    (24) param_list -> . param
    (25) param_list -> . param_list COMMA param
    (107) empty -> .
    (26) param -> . IDENTIFIER
    (27) param -> . IDENTIFIER typehint

    RPAREN          reduce using rule 107 (empty -> .)
    IDENTIFIER      shift and go to state 140

    opt_param_list                 shift and go to state 159
    param_list                     shift and go to state 90
    empty                          shift and go to state 91
    param                          shift and go to state 93

state 139

    (18) lambda_function -> FN LPAREN opt_param_list . RPAREN LAMBDA block_statement
    (19) lambda_function -> FN LPAREN opt_param_list . RPAREN typehint LAMBDA block_statement

    RPAREN          shift and go to state 160


state 140

    (26) param -> IDENTIFIER .
    (27) param -> IDENTIFIER . typehint
    (35) typehint -> . TYPEHINTCOLON type

    COMMA           reduce using rule 26 (param -> IDENTIFIER .)
    RPAREN          reduce using rule 26 (param -> IDENTIFIER .)
    TYPEHINTCOLON   shift and go to state 124

    typehint                       shift and go to state 144

state 141

    (90) simple_expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    CALL            reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    EQUALS          reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 90 (simple_expression -> LPAREN expression RPAREN .)


state 142

    (20) lambda_function -> LPAREN opt_param_list RPAREN . LAMBDA block_statement
    (21) lambda_function -> LPAREN opt_param_list RPAREN . typehint LAMBDA block_statement
    (35) typehint -> . TYPEHINTCOLON type

    LAMBDA          shift and go to state 161
    TYPEHINTCOLON   shift and go to state 124

    typehint                       shift and go to state 162

state 143

    (25) param_list -> param_list COMMA . param
    (26) param -> . IDENTIFIER
    (27) param -> . IDENTIFIER typehint

    IDENTIFIER      shift and go to state 140

    param                          shift and go to state 163

state 144

    (27) param -> IDENTIFIER typehint .

    COMMA           reduce using rule 27 (param -> IDENTIFIER typehint .)
    RPAREN          reduce using rule 27 (param -> IDENTIFIER typehint .)


state 145

    (102) conditional -> IF LPAREN expression . RPAREN block_statement ELSE block_statement
    (103) conditional -> IF LPAREN expression . RPAREN block_statement
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    RPAREN          shift and go to state 164
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 146

    (104) loop -> FOR LPAREN declaration . SEMICOLON expression SEMICOLON expression RPAREN block_statement

    SEMICOLON       shift and go to state 165


state 147

    (14) function_definition -> FN . IDENTIFIER LPAREN opt_param_list RPAREN block_statement
    (15) function_definition -> FN . IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement

    IDENTIFIER      shift and go to state 86


state 148

    (105) loop -> WHILE LPAREN expression . RPAREN block_statement
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    RPAREN          shift and go to state 166
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 149

    (32) declaration_base -> IDENTIFIER ASSIGN expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    SEMICOLON       reduce using rule 32 (declaration_base -> IDENTIFIER ASSIGN expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 150

    (34) declaration_base -> IDENTIFIER typehint ASSIGN . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 167
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 151

    (35) typehint -> TYPEHINTCOLON type .

    ASSIGN          reduce using rule 35 (typehint -> TYPEHINTCOLON type .)
    SEMICOLON       reduce using rule 35 (typehint -> TYPEHINTCOLON type .)
    COMMA           reduce using rule 35 (typehint -> TYPEHINTCOLON type .)
    RPAREN          reduce using rule 35 (typehint -> TYPEHINTCOLON type .)
    LAMBDA          reduce using rule 35 (typehint -> TYPEHINTCOLON type .)
    LBRACE          reduce using rule 35 (typehint -> TYPEHINTCOLON type .)


state 152

    (9) function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .

    SEMICOLON       reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    CALL            reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    PLUS            reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    MINUS           reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    MULTIPLY        reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    DIVIDE          reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    EQUALS          reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    GT              reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    LT              reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    GE              reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    LE              reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    AND             reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    OR              reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    RPAREN          reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)
    COMMA           reduce using rule 9 (function_call -> IDENTIFIER LPAREN opt_arg_list RPAREN .)


state 153

    (13) arg_list -> arg_list COMMA . expression
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 168
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 154

    (84) special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression . RPAREN
    (94) complex_expression -> logic_expression .

    RPAREN          shift and go to state 169
    CALL            reduce using rule 94 (complex_expression -> logic_expression .)
    EQUALS          reduce using rule 94 (complex_expression -> logic_expression .)
    GT              reduce using rule 94 (complex_expression -> logic_expression .)
    LT              reduce using rule 94 (complex_expression -> logic_expression .)
    GE              reduce using rule 94 (complex_expression -> logic_expression .)
    LE              reduce using rule 94 (complex_expression -> logic_expression .)
    AND             reduce using rule 94 (complex_expression -> logic_expression .)
    OR              reduce using rule 94 (complex_expression -> logic_expression .)
    PLUS            reduce using rule 94 (complex_expression -> logic_expression .)
    MINUS           reduce using rule 94 (complex_expression -> logic_expression .)
    MULTIPLY        reduce using rule 94 (complex_expression -> logic_expression .)
    DIVIDE          reduce using rule 94 (complex_expression -> logic_expression .)


state 155

    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression

    CALL            shift and go to state 55
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60

    binary_logic_operation_rest    shift and go to state 56
    binary_arithmetic_operation_rest shift and go to state 54

state 156

    (56) binary_logic_operation -> ptype . binary_logic_operation_rest
    (87) simple_expression -> ptype .
    (52) binary_arithmetic_operation -> ptype . binary_arithmetic_operation_rest
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression

  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    CALL            reduce using rule 87 (simple_expression -> ptype .)
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60

  ! EQUALS          [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LT              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! GE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! LE              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! AND             [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! OR              [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! PLUS            [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MINUS           [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! MULTIPLY        [ reduce using rule 87 (simple_expression -> ptype .) ]
  ! DIVIDE          [ reduce using rule 87 (simple_expression -> ptype .) ]

    binary_logic_operation_rest    shift and go to state 95
    binary_arithmetic_operation_rest shift and go to state 94

state 157

    (85) special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression . RPAREN
    (94) complex_expression -> logic_expression .

    RPAREN          shift and go to state 170
    CALL            reduce using rule 94 (complex_expression -> logic_expression .)
    EQUALS          reduce using rule 94 (complex_expression -> logic_expression .)
    GT              reduce using rule 94 (complex_expression -> logic_expression .)
    LT              reduce using rule 94 (complex_expression -> logic_expression .)
    GE              reduce using rule 94 (complex_expression -> logic_expression .)
    LE              reduce using rule 94 (complex_expression -> logic_expression .)
    AND             reduce using rule 94 (complex_expression -> logic_expression .)
    OR              reduce using rule 94 (complex_expression -> logic_expression .)
    PLUS            reduce using rule 94 (complex_expression -> logic_expression .)
    MINUS           reduce using rule 94 (complex_expression -> logic_expression .)
    MULTIPLY        reduce using rule 94 (complex_expression -> logic_expression .)
    DIVIDE          reduce using rule 94 (complex_expression -> logic_expression .)


state 158

    (86) special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression . RPAREN
    (94) complex_expression -> logic_expression .

    RPAREN          shift and go to state 171
    CALL            reduce using rule 94 (complex_expression -> logic_expression .)
    EQUALS          reduce using rule 94 (complex_expression -> logic_expression .)
    GT              reduce using rule 94 (complex_expression -> logic_expression .)
    LT              reduce using rule 94 (complex_expression -> logic_expression .)
    GE              reduce using rule 94 (complex_expression -> logic_expression .)
    LE              reduce using rule 94 (complex_expression -> logic_expression .)
    AND             reduce using rule 94 (complex_expression -> logic_expression .)
    OR              reduce using rule 94 (complex_expression -> logic_expression .)
    PLUS            reduce using rule 94 (complex_expression -> logic_expression .)
    MINUS           reduce using rule 94 (complex_expression -> logic_expression .)
    MULTIPLY        reduce using rule 94 (complex_expression -> logic_expression .)
    DIVIDE          reduce using rule 94 (complex_expression -> logic_expression .)


state 159

    (14) function_definition -> FN IDENTIFIER LPAREN opt_param_list . RPAREN block_statement
    (15) function_definition -> FN IDENTIFIER LPAREN opt_param_list . RPAREN typehint block_statement

    RPAREN          shift and go to state 172


state 160

    (18) lambda_function -> FN LPAREN opt_param_list RPAREN . LAMBDA block_statement
    (19) lambda_function -> FN LPAREN opt_param_list RPAREN . typehint LAMBDA block_statement
    (35) typehint -> . TYPEHINTCOLON type

    LAMBDA          shift and go to state 173
    TYPEHINTCOLON   shift and go to state 124

    typehint                       shift and go to state 174

state 161

    (20) lambda_function -> LPAREN opt_param_list RPAREN LAMBDA . block_statement
    (17) block_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 176

    block_statement                shift and go to state 175

state 162

    (21) lambda_function -> LPAREN opt_param_list RPAREN typehint . LAMBDA block_statement

    LAMBDA          shift and go to state 177


state 163

    (25) param_list -> param_list COMMA param .

    COMMA           reduce using rule 25 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 25 (param_list -> param_list COMMA param .)


state 164

    (102) conditional -> IF LPAREN expression RPAREN . block_statement ELSE block_statement
    (103) conditional -> IF LPAREN expression RPAREN . block_statement
    (17) block_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 176

    block_statement                shift and go to state 178

state 165

    (104) loop -> FOR LPAREN declaration SEMICOLON . expression SEMICOLON expression RPAREN block_statement
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 179
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 166

    (105) loop -> WHILE LPAREN expression RPAREN . block_statement
    (17) block_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 176

    block_statement                shift and go to state 180

state 167

    (34) declaration_base -> IDENTIFIER typehint ASSIGN expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    SEMICOLON       reduce using rule 34 (declaration_base -> IDENTIFIER typehint ASSIGN expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 168

    (13) arg_list -> arg_list COMMA expression .
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    COMMA           reduce using rule 13 (arg_list -> arg_list COMMA expression .)
    RPAREN          reduce using rule 13 (arg_list -> arg_list COMMA expression .)
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 169

    (84) special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .

    SEMICOLON       reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    CALL            reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    PLUS            reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    MINUS           reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    MULTIPLY        reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    DIVIDE          reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    EQUALS          reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    GT              reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    LT              reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    GE              reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    LE              reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    AND             reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    OR              reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    RPAREN          reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)
    COMMA           reduce using rule 84 (special_stream_operation -> IDENTIFIER FILTEROP LPAREN logic_expression RPAREN .)


state 170

    (85) special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .

    SEMICOLON       reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    CALL            reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    PLUS            reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    MINUS           reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    MULTIPLY        reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    DIVIDE          reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    EQUALS          reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    GT              reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    LT              reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    GE              reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    LE              reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    AND             reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    OR              reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    RPAREN          reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)
    COMMA           reduce using rule 85 (special_stream_operation -> IDENTIFIER MAP LPAREN logic_expression RPAREN .)


state 171

    (86) special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .

    SEMICOLON       reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    CALL            reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    PLUS            reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    MINUS           reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    MULTIPLY        reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    DIVIDE          reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    EQUALS          reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    GT              reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    LT              reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    GE              reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    LE              reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    AND             reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    OR              reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    RPAREN          reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)
    COMMA           reduce using rule 86 (special_stream_operation -> IDENTIFIER REDUCE LPAREN logic_expression RPAREN .)


state 172

    (14) function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN . block_statement
    (15) function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN . typehint block_statement
    (17) block_statement -> . LBRACE statement_list RBRACE
    (35) typehint -> . TYPEHINTCOLON type

    LBRACE          shift and go to state 176
    TYPEHINTCOLON   shift and go to state 124

    block_statement                shift and go to state 181
    typehint                       shift and go to state 182

state 173

    (18) lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA . block_statement
    (17) block_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 176

    block_statement                shift and go to state 183

state 174

    (19) lambda_function -> FN LPAREN opt_param_list RPAREN typehint . LAMBDA block_statement

    LAMBDA          shift and go to state 184


state 175

    (20) lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .

    SEMICOLON       reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    CALL            reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    PLUS            reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    MINUS           reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    MULTIPLY        reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    DIVIDE          reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    EQUALS          reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    GT              reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    LT              reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    GE              reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    LE              reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    AND             reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    OR              reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    RPAREN          reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    COMMA           reduce using rule 20 (lambda_function -> LPAREN opt_param_list RPAREN LAMBDA block_statement .)


state 176

    (17) block_statement -> LBRACE . statement_list RBRACE
    (7) statement_list -> . statement
    (8) statement_list -> . statement_list statement
    (2) statement -> . declaration
    (3) statement -> . expression SEMICOLON
    (4) statement -> . return_statement SEMICOLON
    (5) statement -> . control_flow
    (6) statement -> . assignment SEMICOLON
    (28) declaration -> . VAR declaration_base SEMICOLON
    (29) declaration -> . CONST declaration_base SEMICOLON
    (30) declaration -> . function_definition
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (16) return_statement -> . RETURN expression
    (100) control_flow -> . conditional
    (101) control_flow -> . loop
    (106) assignment -> . IDENTIFIER ASSIGN expression
    (14) function_definition -> . FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement
    (15) function_definition -> . FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (102) conditional -> . IF LPAREN expression RPAREN block_statement ELSE block_statement
    (103) conditional -> . IF LPAREN expression RPAREN block_statement
    (104) loop -> . FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement
    (105) loop -> . WHILE LPAREN expression RPAREN block_statement
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    VAR             shift and go to state 9
    CONST           shift and go to state 10
    RETURN          shift and go to state 14
    IDENTIFIER      shift and go to state 17
    FN              shift and go to state 18
    LPAREN          shift and go to state 19
    IF              shift and go to state 29
    FOR             shift and go to state 30
    WHILE           shift and go to state 31
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    statement_list                 shift and go to state 185
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    expression                     shift and go to state 5
    return_statement               shift and go to state 6
    control_flow                   shift and go to state 7
    assignment                     shift and go to state 8
    function_definition            shift and go to state 11
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    conditional                    shift and go to state 15
    loop                           shift and go to state 16
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 177

    (21) lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA . block_statement
    (17) block_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 176

    block_statement                shift and go to state 186

state 178

    (102) conditional -> IF LPAREN expression RPAREN block_statement . ELSE block_statement
    (103) conditional -> IF LPAREN expression RPAREN block_statement .

    ELSE            shift and go to state 187
    VAR             reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    CONST           reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    RETURN          reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    IDENTIFIER      reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    FN              reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    LPAREN          reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    IF              reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    FOR             reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    WHILE           reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    INT             reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    FLOAT           reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    STRING          reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    TRUE            reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    FALSE           reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    SINT            reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    SFLOAT          reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    SSTRING         reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    SBOOL           reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    SSTREAM         reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    SEVENT          reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    MINUS           reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    PLUS            reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    NOT             reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    $end            reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)
    RBRACE          reduce using rule 103 (conditional -> IF LPAREN expression RPAREN block_statement .)


state 179

    (104) loop -> FOR LPAREN declaration SEMICOLON expression . SEMICOLON expression RPAREN block_statement
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    SEMICOLON       shift and go to state 188
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 180

    (105) loop -> WHILE LPAREN expression RPAREN block_statement .

    VAR             reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    CONST           reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    RETURN          reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    IDENTIFIER      reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    FN              reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    LPAREN          reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    IF              reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    FOR             reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    WHILE           reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    INT             reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    FLOAT           reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    STRING          reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    TRUE            reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    FALSE           reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    SINT            reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    SFLOAT          reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    SSTRING         reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    SBOOL           reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    SSTREAM         reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    SEVENT          reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    MINUS           reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    PLUS            reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    NOT             reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    $end            reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)
    RBRACE          reduce using rule 105 (loop -> WHILE LPAREN expression RPAREN block_statement .)


state 181

    (14) function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .

    VAR             reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    CONST           reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    RETURN          reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    IDENTIFIER      reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    FN              reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    LPAREN          reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    IF              reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    FOR             reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    WHILE           reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    INT             reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    FLOAT           reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    STRING          reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    TRUE            reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    FALSE           reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    SINT            reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    SFLOAT          reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    SSTRING         reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    SBOOL           reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    SSTREAM         reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    SEVENT          reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    MINUS           reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    PLUS            reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    NOT             reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    $end            reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    SEMICOLON       reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)
    RBRACE          reduce using rule 14 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement .)


state 182

    (15) function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint . block_statement
    (17) block_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 176

    block_statement                shift and go to state 189

state 183

    (18) lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .

    SEMICOLON       reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    CALL            reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    PLUS            reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    MINUS           reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    MULTIPLY        reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    DIVIDE          reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    EQUALS          reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    GT              reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    LT              reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    GE              reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    LE              reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    AND             reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    OR              reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    RPAREN          reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)
    COMMA           reduce using rule 18 (lambda_function -> FN LPAREN opt_param_list RPAREN LAMBDA block_statement .)


state 184

    (19) lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA . block_statement
    (17) block_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 176

    block_statement                shift and go to state 190

state 185

    (17) block_statement -> LBRACE statement_list . RBRACE
    (8) statement_list -> statement_list . statement
    (2) statement -> . declaration
    (3) statement -> . expression SEMICOLON
    (4) statement -> . return_statement SEMICOLON
    (5) statement -> . control_flow
    (6) statement -> . assignment SEMICOLON
    (28) declaration -> . VAR declaration_base SEMICOLON
    (29) declaration -> . CONST declaration_base SEMICOLON
    (30) declaration -> . function_definition
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (16) return_statement -> . RETURN expression
    (100) control_flow -> . conditional
    (101) control_flow -> . loop
    (106) assignment -> . IDENTIFIER ASSIGN expression
    (14) function_definition -> . FN IDENTIFIER LPAREN opt_param_list RPAREN block_statement
    (15) function_definition -> . FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (102) conditional -> . IF LPAREN expression RPAREN block_statement ELSE block_statement
    (103) conditional -> . IF LPAREN expression RPAREN block_statement
    (104) loop -> . FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement
    (105) loop -> . WHILE LPAREN expression RPAREN block_statement
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    RBRACE          shift and go to state 191
    VAR             shift and go to state 9
    CONST           shift and go to state 10
    RETURN          shift and go to state 14
    IDENTIFIER      shift and go to state 17
    FN              shift and go to state 18
    LPAREN          shift and go to state 19
    IF              shift and go to state 29
    FOR             shift and go to state 30
    WHILE           shift and go to state 31
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    statement                      shift and go to state 52
    declaration                    shift and go to state 4
    expression                     shift and go to state 5
    return_statement               shift and go to state 6
    control_flow                   shift and go to state 7
    assignment                     shift and go to state 8
    function_definition            shift and go to state 11
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    conditional                    shift and go to state 15
    loop                           shift and go to state 16
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 186

    (21) lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .

    SEMICOLON       reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    CALL            reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    PLUS            reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    MINUS           reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    MULTIPLY        reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    DIVIDE          reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    EQUALS          reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    GT              reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    LT              reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    GE              reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    LE              reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    AND             reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    OR              reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    RPAREN          reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    COMMA           reduce using rule 21 (lambda_function -> LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)


state 187

    (102) conditional -> IF LPAREN expression RPAREN block_statement ELSE . block_statement
    (17) block_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 176

    block_statement                shift and go to state 192

state 188

    (104) loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON . expression RPAREN block_statement
    (98) expression -> . simple_expression
    (99) expression -> . complex_expression
    (87) simple_expression -> . ptype
    (88) simple_expression -> . type
    (89) simple_expression -> . IDENTIFIER
    (90) simple_expression -> . LPAREN expression RPAREN
    (91) simple_expression -> . lambda_function
    (92) complex_expression -> . binary_arithmetic_operation
    (93) complex_expression -> . unary_arithmetic_operation
    (94) complex_expression -> . logic_expression
    (95) complex_expression -> . function_call_expression
    (96) complex_expression -> . object_call_expression
    (97) complex_expression -> . stream_operation
    (42) ptype -> . INT
    (43) ptype -> . FLOAT
    (44) ptype -> . STRING
    (45) ptype -> . TRUE
    (46) ptype -> . FALSE
    (36) type -> . SINT
    (37) type -> . SFLOAT
    (38) type -> . SSTRING
    (39) type -> . SBOOL
    (40) type -> . SSTREAM
    (41) type -> . SEVENT
    (18) lambda_function -> . FN LPAREN opt_param_list RPAREN LAMBDA block_statement
    (19) lambda_function -> . FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (20) lambda_function -> . LPAREN opt_param_list RPAREN LAMBDA block_statement
    (21) lambda_function -> . LPAREN opt_param_list RPAREN typehint LAMBDA block_statement
    (51) binary_arithmetic_operation -> . expression binary_arithmetic_operation_rest
    (52) binary_arithmetic_operation -> . ptype binary_arithmetic_operation_rest
    (53) unary_arithmetic_operation -> . MINUS expression
    (54) unary_arithmetic_operation -> . PLUS expression
    (72) logic_expression -> . binary_logic_operation
    (73) logic_expression -> . unary_logic_operation
    (74) function_call_expression -> . function_call
    (75) object_call_expression -> . expression CALL expression
    (76) stream_operation -> . unary_stream_operation
    (77) stream_operation -> . binary_stream_operation
    (78) stream_operation -> . special_stream_operation
    (55) binary_logic_operation -> . expression binary_logic_operation_rest
    (56) binary_logic_operation -> . ptype binary_logic_operation_rest
    (71) unary_logic_operation -> . NOT expression
    (9) function_call -> . IDENTIFIER LPAREN opt_arg_list RPAREN
    (79) unary_stream_operation -> . IDENTIFIER TO_STREAM
    (80) binary_stream_operation -> . IDENTIFIER CHAIN IDENTIFIER
    (81) binary_stream_operation -> . IDENTIFIER STREAMSPLIT IDENTIFIER
    (82) binary_stream_operation -> . IDENTIFIER STREAMMERGE IDENTIFIER
    (83) binary_stream_operation -> . IDENTIFIER FEEDBACK IDENTIFIER
    (84) special_stream_operation -> . IDENTIFIER FILTEROP LPAREN logic_expression RPAREN
    (85) special_stream_operation -> . IDENTIFIER MAP LPAREN logic_expression RPAREN
    (86) special_stream_operation -> . IDENTIFIER REDUCE LPAREN logic_expression RPAREN

    IDENTIFIER      shift and go to state 74
    LPAREN          shift and go to state 19
    INT             shift and go to state 32
    FLOAT           shift and go to state 33
    STRING          shift and go to state 34
    TRUE            shift and go to state 35
    FALSE           shift and go to state 36
    SINT            shift and go to state 37
    SFLOAT          shift and go to state 38
    SSTRING         shift and go to state 39
    SBOOL           shift and go to state 40
    SSTREAM         shift and go to state 41
    SEVENT          shift and go to state 42
    FN              shift and go to state 75
    MINUS           shift and go to state 43
    PLUS            shift and go to state 44
    NOT             shift and go to state 51

    expression                     shift and go to state 193
    simple_expression              shift and go to state 12
    complex_expression             shift and go to state 13
    ptype                          shift and go to state 20
    type                           shift and go to state 21
    lambda_function                shift and go to state 22
    binary_arithmetic_operation    shift and go to state 23
    unary_arithmetic_operation     shift and go to state 24
    logic_expression               shift and go to state 25
    function_call_expression       shift and go to state 26
    object_call_expression         shift and go to state 27
    stream_operation               shift and go to state 28
    binary_logic_operation         shift and go to state 45
    unary_logic_operation          shift and go to state 46
    function_call                  shift and go to state 47
    unary_stream_operation         shift and go to state 48
    binary_stream_operation        shift and go to state 49
    special_stream_operation       shift and go to state 50

state 189

    (15) function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .

    VAR             reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    CONST           reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    RETURN          reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    IDENTIFIER      reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    FN              reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    LPAREN          reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    IF              reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    FOR             reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    WHILE           reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    INT             reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    FLOAT           reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    STRING          reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    TRUE            reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    FALSE           reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    SINT            reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    SFLOAT          reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    SSTRING         reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    SBOOL           reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    SSTREAM         reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    SEVENT          reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    MINUS           reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    PLUS            reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    NOT             reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    $end            reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    SEMICOLON       reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)
    RBRACE          reduce using rule 15 (function_definition -> FN IDENTIFIER LPAREN opt_param_list RPAREN typehint block_statement .)


state 190

    (19) lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .

    SEMICOLON       reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    CALL            reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    PLUS            reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    MINUS           reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    MULTIPLY        reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    DIVIDE          reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    EQUALS          reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    GT              reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    LT              reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    GE              reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    LE              reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    AND             reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    OR              reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    RPAREN          reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)
    COMMA           reduce using rule 19 (lambda_function -> FN LPAREN opt_param_list RPAREN typehint LAMBDA block_statement .)


state 191

    (17) block_statement -> LBRACE statement_list RBRACE .

    SEMICOLON       reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    CALL            reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    PLUS            reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    MULTIPLY        reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    DIVIDE          reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    EQUALS          reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    GT              reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    LT              reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    GE              reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    LE              reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    AND             reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    OR              reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    RPAREN          reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    COMMA           reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    VAR             reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    CONST           reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    FN              reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    INT             reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    STRING          reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    SINT            reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    SFLOAT          reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    SSTRING         reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    SBOOL           reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    SSTREAM         reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    SEVENT          reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    NOT             reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 17 (block_statement -> LBRACE statement_list RBRACE .)


state 192

    (102) conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .

    VAR             reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    CONST           reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    RETURN          reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    IDENTIFIER      reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    FN              reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    LPAREN          reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    IF              reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    FOR             reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    WHILE           reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    INT             reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    FLOAT           reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    STRING          reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    TRUE            reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    FALSE           reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    SINT            reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    SFLOAT          reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    SSTRING         reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    SBOOL           reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    SSTREAM         reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    SEVENT          reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    MINUS           reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    PLUS            reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    NOT             reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    $end            reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)
    RBRACE          reduce using rule 102 (conditional -> IF LPAREN expression RPAREN block_statement ELSE block_statement .)


state 193

    (104) loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression . RPAREN block_statement
    (51) binary_arithmetic_operation -> expression . binary_arithmetic_operation_rest
    (75) object_call_expression -> expression . CALL expression
    (55) binary_logic_operation -> expression . binary_logic_operation_rest
    (47) binary_arithmetic_operation_rest -> . PLUS expression
    (48) binary_arithmetic_operation_rest -> . MINUS expression
    (49) binary_arithmetic_operation_rest -> . MULTIPLY expression
    (50) binary_arithmetic_operation_rest -> . DIVIDE expression
    (57) binary_logic_operation_rest -> . EQUALS ptype
    (58) binary_logic_operation_rest -> . GT ptype
    (59) binary_logic_operation_rest -> . LT ptype
    (60) binary_logic_operation_rest -> . GE ptype
    (61) binary_logic_operation_rest -> . LE ptype
    (62) binary_logic_operation_rest -> . AND ptype
    (63) binary_logic_operation_rest -> . OR ptype
    (64) binary_logic_operation_rest -> . EQUALS expression
    (65) binary_logic_operation_rest -> . GT expression
    (66) binary_logic_operation_rest -> . LT expression
    (67) binary_logic_operation_rest -> . GE expression
    (68) binary_logic_operation_rest -> . LE expression
    (69) binary_logic_operation_rest -> . AND expression
    (70) binary_logic_operation_rest -> . OR expression

    RPAREN          shift and go to state 194
    CALL            shift and go to state 55
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    MULTIPLY        shift and go to state 59
    DIVIDE          shift and go to state 60
    EQUALS          shift and go to state 61
    GT              shift and go to state 62
    LT              shift and go to state 63
    GE              shift and go to state 64
    LE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

    binary_arithmetic_operation_rest shift and go to state 54
    binary_logic_operation_rest    shift and go to state 56

state 194

    (104) loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN . block_statement
    (17) block_statement -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 176

    block_statement                shift and go to state 195

state 195

    (104) loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .

    VAR             reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    CONST           reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    RETURN          reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    IDENTIFIER      reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    FN              reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    LPAREN          reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    IF              reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    FOR             reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    WHILE           reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    INT             reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    FLOAT           reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    STRING          reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    TRUE            reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    FALSE           reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    SINT            reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    SFLOAT          reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    SSTRING         reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    SBOOL           reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    SSTREAM         reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    SEVENT          reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    MINUS           reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    PLUS            reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    NOT             reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    $end            reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)
    RBRACE          reduce using rule 104 (loop -> FOR LPAREN declaration SEMICOLON expression SEMICOLON expression RPAREN block_statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 20 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 20 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 20 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 20 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 20 resolved as shift
WARNING: shift/reduce conflict for GT in state 20 resolved as shift
WARNING: shift/reduce conflict for LT in state 20 resolved as shift
WARNING: shift/reduce conflict for GE in state 20 resolved as shift
WARNING: shift/reduce conflict for LE in state 20 resolved as shift
WARNING: shift/reduce conflict for AND in state 20 resolved as shift
WARNING: shift/reduce conflict for OR in state 20 resolved as shift
WARNING: shift/reduce conflict for CALL in state 99 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 99 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 99 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 99 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 99 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 99 resolved as shift
WARNING: shift/reduce conflict for GT in state 99 resolved as shift
WARNING: shift/reduce conflict for LT in state 99 resolved as shift
WARNING: shift/reduce conflict for GE in state 99 resolved as shift
WARNING: shift/reduce conflict for LE in state 99 resolved as shift
WARNING: shift/reduce conflict for AND in state 99 resolved as shift
WARNING: shift/reduce conflict for OR in state 99 resolved as shift
WARNING: shift/reduce conflict for CALL in state 100 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 100 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 100 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 100 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 100 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 100 resolved as shift
WARNING: shift/reduce conflict for GT in state 100 resolved as shift
WARNING: shift/reduce conflict for LT in state 100 resolved as shift
WARNING: shift/reduce conflict for GE in state 100 resolved as shift
WARNING: shift/reduce conflict for LE in state 100 resolved as shift
WARNING: shift/reduce conflict for AND in state 100 resolved as shift
WARNING: shift/reduce conflict for OR in state 100 resolved as shift
WARNING: shift/reduce conflict for CALL in state 101 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 101 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 101 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 101 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 101 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 101 resolved as shift
WARNING: shift/reduce conflict for GT in state 101 resolved as shift
WARNING: shift/reduce conflict for LT in state 101 resolved as shift
WARNING: shift/reduce conflict for GE in state 101 resolved as shift
WARNING: shift/reduce conflict for LE in state 101 resolved as shift
WARNING: shift/reduce conflict for AND in state 101 resolved as shift
WARNING: shift/reduce conflict for OR in state 101 resolved as shift
WARNING: shift/reduce conflict for CALL in state 102 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 102 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 102 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 102 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 102 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 102 resolved as shift
WARNING: shift/reduce conflict for GT in state 102 resolved as shift
WARNING: shift/reduce conflict for LT in state 102 resolved as shift
WARNING: shift/reduce conflict for GE in state 102 resolved as shift
WARNING: shift/reduce conflict for LE in state 102 resolved as shift
WARNING: shift/reduce conflict for AND in state 102 resolved as shift
WARNING: shift/reduce conflict for OR in state 102 resolved as shift
WARNING: shift/reduce conflict for CALL in state 103 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 103 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 103 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 103 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 103 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 103 resolved as shift
WARNING: shift/reduce conflict for GT in state 103 resolved as shift
WARNING: shift/reduce conflict for LT in state 103 resolved as shift
WARNING: shift/reduce conflict for GE in state 103 resolved as shift
WARNING: shift/reduce conflict for LE in state 103 resolved as shift
WARNING: shift/reduce conflict for AND in state 103 resolved as shift
WARNING: shift/reduce conflict for OR in state 103 resolved as shift
WARNING: shift/reduce conflict for CALL in state 104 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 104 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 104 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 104 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 104 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 104 resolved as shift
WARNING: shift/reduce conflict for GT in state 104 resolved as shift
WARNING: shift/reduce conflict for LT in state 104 resolved as shift
WARNING: shift/reduce conflict for GE in state 104 resolved as shift
WARNING: shift/reduce conflict for LE in state 104 resolved as shift
WARNING: shift/reduce conflict for AND in state 104 resolved as shift
WARNING: shift/reduce conflict for OR in state 104 resolved as shift
WARNING: shift/reduce conflict for CALL in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 105 resolved as shift
WARNING: shift/reduce conflict for GT in state 105 resolved as shift
WARNING: shift/reduce conflict for LT in state 105 resolved as shift
WARNING: shift/reduce conflict for GE in state 105 resolved as shift
WARNING: shift/reduce conflict for LE in state 105 resolved as shift
WARNING: shift/reduce conflict for AND in state 105 resolved as shift
WARNING: shift/reduce conflict for OR in state 105 resolved as shift
WARNING: shift/reduce conflict for CALL in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 106 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 106 resolved as shift
WARNING: shift/reduce conflict for GT in state 106 resolved as shift
WARNING: shift/reduce conflict for LT in state 106 resolved as shift
WARNING: shift/reduce conflict for GE in state 106 resolved as shift
WARNING: shift/reduce conflict for LE in state 106 resolved as shift
WARNING: shift/reduce conflict for AND in state 106 resolved as shift
WARNING: shift/reduce conflict for OR in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 107 resolved as shift
WARNING: shift/reduce conflict for GT in state 107 resolved as shift
WARNING: shift/reduce conflict for LT in state 107 resolved as shift
WARNING: shift/reduce conflict for GE in state 107 resolved as shift
WARNING: shift/reduce conflict for LE in state 107 resolved as shift
WARNING: shift/reduce conflict for AND in state 107 resolved as shift
WARNING: shift/reduce conflict for OR in state 107 resolved as shift
WARNING: shift/reduce conflict for CALL in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 108 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 108 resolved as shift
WARNING: shift/reduce conflict for GT in state 108 resolved as shift
WARNING: shift/reduce conflict for LT in state 108 resolved as shift
WARNING: shift/reduce conflict for GE in state 108 resolved as shift
WARNING: shift/reduce conflict for LE in state 108 resolved as shift
WARNING: shift/reduce conflict for AND in state 108 resolved as shift
WARNING: shift/reduce conflict for OR in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 109 resolved as shift
WARNING: shift/reduce conflict for GT in state 109 resolved as shift
WARNING: shift/reduce conflict for LT in state 109 resolved as shift
WARNING: shift/reduce conflict for GE in state 109 resolved as shift
WARNING: shift/reduce conflict for LE in state 109 resolved as shift
WARNING: shift/reduce conflict for AND in state 109 resolved as shift
WARNING: shift/reduce conflict for OR in state 109 resolved as shift
WARNING: shift/reduce conflict for CALL in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 110 resolved as shift
WARNING: shift/reduce conflict for GT in state 110 resolved as shift
WARNING: shift/reduce conflict for LT in state 110 resolved as shift
WARNING: shift/reduce conflict for GE in state 110 resolved as shift
WARNING: shift/reduce conflict for LE in state 110 resolved as shift
WARNING: shift/reduce conflict for AND in state 110 resolved as shift
WARNING: shift/reduce conflict for OR in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 111 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 111 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 111 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 111 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 111 resolved as shift
WARNING: shift/reduce conflict for GT in state 111 resolved as shift
WARNING: shift/reduce conflict for LT in state 111 resolved as shift
WARNING: shift/reduce conflict for GE in state 111 resolved as shift
WARNING: shift/reduce conflict for LE in state 111 resolved as shift
WARNING: shift/reduce conflict for AND in state 111 resolved as shift
WARNING: shift/reduce conflict for OR in state 111 resolved as shift
WARNING: shift/reduce conflict for CALL in state 112 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 112 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 112 resolved as shift
WARNING: shift/reduce conflict for GT in state 112 resolved as shift
WARNING: shift/reduce conflict for LT in state 112 resolved as shift
WARNING: shift/reduce conflict for GE in state 112 resolved as shift
WARNING: shift/reduce conflict for LE in state 112 resolved as shift
WARNING: shift/reduce conflict for AND in state 112 resolved as shift
WARNING: shift/reduce conflict for OR in state 112 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 113 resolved as shift
WARNING: shift/reduce conflict for GT in state 113 resolved as shift
WARNING: shift/reduce conflict for LT in state 113 resolved as shift
WARNING: shift/reduce conflict for GE in state 113 resolved as shift
WARNING: shift/reduce conflict for LE in state 113 resolved as shift
WARNING: shift/reduce conflict for AND in state 113 resolved as shift
WARNING: shift/reduce conflict for OR in state 113 resolved as shift
WARNING: shift/reduce conflict for CALL in state 114 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 114 resolved as shift
WARNING: shift/reduce conflict for GT in state 114 resolved as shift
WARNING: shift/reduce conflict for LT in state 114 resolved as shift
WARNING: shift/reduce conflict for GE in state 114 resolved as shift
WARNING: shift/reduce conflict for LE in state 114 resolved as shift
WARNING: shift/reduce conflict for AND in state 114 resolved as shift
WARNING: shift/reduce conflict for OR in state 114 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 115 resolved as shift
WARNING: shift/reduce conflict for GT in state 115 resolved as shift
WARNING: shift/reduce conflict for LT in state 115 resolved as shift
WARNING: shift/reduce conflict for GE in state 115 resolved as shift
WARNING: shift/reduce conflict for LE in state 115 resolved as shift
WARNING: shift/reduce conflict for AND in state 115 resolved as shift
WARNING: shift/reduce conflict for OR in state 115 resolved as shift
WARNING: shift/reduce conflict for CALL in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 116 resolved as shift
WARNING: shift/reduce conflict for GT in state 116 resolved as shift
WARNING: shift/reduce conflict for LT in state 116 resolved as shift
WARNING: shift/reduce conflict for GE in state 116 resolved as shift
WARNING: shift/reduce conflict for LE in state 116 resolved as shift
WARNING: shift/reduce conflict for AND in state 116 resolved as shift
WARNING: shift/reduce conflict for OR in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 117 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 117 resolved as shift
WARNING: shift/reduce conflict for GT in state 117 resolved as shift
WARNING: shift/reduce conflict for LT in state 117 resolved as shift
WARNING: shift/reduce conflict for GE in state 117 resolved as shift
WARNING: shift/reduce conflict for LE in state 117 resolved as shift
WARNING: shift/reduce conflict for AND in state 117 resolved as shift
WARNING: shift/reduce conflict for OR in state 117 resolved as shift
WARNING: shift/reduce conflict for CALL in state 118 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 118 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 118 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 118 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 118 resolved as shift
WARNING: shift/reduce conflict for GT in state 118 resolved as shift
WARNING: shift/reduce conflict for LT in state 118 resolved as shift
WARNING: shift/reduce conflict for GE in state 118 resolved as shift
WARNING: shift/reduce conflict for LE in state 118 resolved as shift
WARNING: shift/reduce conflict for AND in state 118 resolved as shift
WARNING: shift/reduce conflict for OR in state 118 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 119 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 119 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 119 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 119 resolved as shift
WARNING: shift/reduce conflict for GT in state 119 resolved as shift
WARNING: shift/reduce conflict for LT in state 119 resolved as shift
WARNING: shift/reduce conflict for GE in state 119 resolved as shift
WARNING: shift/reduce conflict for LE in state 119 resolved as shift
WARNING: shift/reduce conflict for AND in state 119 resolved as shift
WARNING: shift/reduce conflict for OR in state 119 resolved as shift
WARNING: shift/reduce conflict for CALL in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 120 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 120 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 120 resolved as shift
WARNING: shift/reduce conflict for GT in state 120 resolved as shift
WARNING: shift/reduce conflict for LT in state 120 resolved as shift
WARNING: shift/reduce conflict for GE in state 120 resolved as shift
WARNING: shift/reduce conflict for LE in state 120 resolved as shift
WARNING: shift/reduce conflict for AND in state 120 resolved as shift
WARNING: shift/reduce conflict for OR in state 120 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 156 resolved as shift
WARNING: shift/reduce conflict for GT in state 156 resolved as shift
WARNING: shift/reduce conflict for LT in state 156 resolved as shift
WARNING: shift/reduce conflict for GE in state 156 resolved as shift
WARNING: shift/reduce conflict for LE in state 156 resolved as shift
WARNING: shift/reduce conflict for AND in state 156 resolved as shift
WARNING: shift/reduce conflict for OR in state 156 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 156 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 156 resolved as shift
WARNING: reduce/reduce conflict in state 92 resolved using rule (param -> IDENTIFIER)
WARNING: rejected rule (simple_expression -> IDENTIFIER) in state 92
WARNING: reduce/reduce conflict in state 107 resolved using rule (binary_logic_operation_rest -> EQUALS ptype)
WARNING: rejected rule (simple_expression -> ptype) in state 107
WARNING: reduce/reduce conflict in state 109 resolved using rule (binary_logic_operation_rest -> GT ptype)
WARNING: rejected rule (simple_expression -> ptype) in state 109
WARNING: reduce/reduce conflict in state 111 resolved using rule (binary_logic_operation_rest -> LT ptype)
WARNING: rejected rule (simple_expression -> ptype) in state 111
WARNING: reduce/reduce conflict in state 113 resolved using rule (binary_logic_operation_rest -> GE ptype)
WARNING: rejected rule (simple_expression -> ptype) in state 113
WARNING: reduce/reduce conflict in state 115 resolved using rule (binary_logic_operation_rest -> LE ptype)
WARNING: rejected rule (simple_expression -> ptype) in state 115
WARNING: reduce/reduce conflict in state 117 resolved using rule (binary_logic_operation_rest -> AND ptype)
WARNING: rejected rule (simple_expression -> ptype) in state 117
WARNING: reduce/reduce conflict in state 119 resolved using rule (binary_logic_operation_rest -> OR ptype)
WARNING: rejected rule (simple_expression -> ptype) in state 119
